\newcommand{\parfait}{\texttt{Parfait}\xspace}
\newcommand{\cqual}{\texttt{CQual}\xspace}
\newcommand{\dytan}{\texttt{Dytan}\xspace}
\newcommand{\pixy}{\texttt{Pixy}\xspace}
\newcommand{\ardilla}{\texttt{ARDILLA}\xspace}
\newcommand{\taintcheck}{\texttt{TaintCheck}\xspace}
\newcommand{\libsafe}{\texttt{Libsafe}\xspace}

\newcommand{\valgrind}{\texttt{Valgrind}\xspace}
\newcommand{\datalog}{\texttt{Datalog}\xspace}
\newcommand{\bddbddb}{\texttt{bddbddb}\xspace}
\newcommand{\pql}{\texttt{PQL}\xspace}

\begin{table*}[!htbp]
\centering
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
		 	& 				& 					& 					 	&	 				& 				 	& 					\\
{\bf Name}	& {\bf Language}& {\bf Requires }	& {\bf Technique }		&{\bf False Positives}& {\bf Bug Type}	& {\bf Availability}\\ 
 			& 				& {\bf Annotation}	&						&	{\bf Rate}		&					&					\\	\hline
	  																																	\hline
Parfait	    & C, C++		&					&	IDF / CIDF			&					&					&	Commercial		\\ 
Coverity	& C, C++, Java  &					&						&					&					&	Commercial		\\ 
VeraCode	& C, C++, Java  &					&						&					&					&	Commercial		\\ 
Klocwork	& C, C++, Java  &					&	IDF					&					&					&	Commercial		\\ 
TAJ			& Java  		&					&	IDF					&					&					&	Commercial		\\ 
CQual	 	& C 			&	Yes				&	Type system			&					&   				&	Research		\\ 
Pixy		& PHP			&					&						&					&					&	Research		\\ 
Archer	 	& C				&					&	SA					&					&   				&	Research		\\
Splint		& C 			&	Yes				&						&					&					&	Research		\\
Jlint		& Java			&					&	Data flow			&					&					&	Research		\\
\waint		& C				&					&	IDF	/ CIDF			&					&					&	Research		\\\hline
\end{tabular}\caption{Static Analysis Tool for Security Vulnerability\\
AI: Abstract Interpretation, 
IDF: Interprocedural Data flow Analysis, 
CIDF: Context-Sensitive Interprocedural Data flow Analysis }
\end{table*}

\begin{table*}[!htbp]
\centering
\begin{tabular}{|l|l|c|c|c|}
\hline
{\bf Name}		&  {\bf Technique }		&{\bf False Positives Rate}& {\bf Bug Type}	& {\bf Availability}\\ \hline \hline
Dytan	    	& 	IDF / CIDF			&					&					&	Research			\\ 
TaintCheck		& 						&					&					&	Research			\\ 
LibSafe $2.0$	& 	IDF					&					&					&	Research			\\ \hline
\end{tabular}\caption{Dynamic Analysis Tool for Security Vulnerability\\
AI: Abstract Interpretation, 
IDF: Interprocedural Data flow Analysis, 
CIDF: Context-Sensitive Interprocedural Data flow Analysis }
\end{table*}

\section{Related Work}\label{sec:related}

There has been a lot of work in the area of taint analysis
and its applications. This section presents some taint
analysis based projects that rely on static, dynamic,
hybrid analysis or symbolic evaluation.

\begin{comment}
The tremendous amount of program analysis tools for software
security\cite{Tripp:2009:TAJ, Kiezun:2009:Ardilla,
Chang:2009:ICS, Parfait:2008, Jovanovic:2006:Pixy,
livshits05finding, Avots:2005:ISS, Shankar:2001:DFS, Engler:2000:CSR,
KMPS2011, Clause:2007:Dytan, Balzarotti:2008:SCS4} is an indication of
the importance of the subject.
%Each work can generally be classified within three main categories:
%static tools\cite{Tripp:2009:TAJ, Kiezun:2009:Ardilla, Chang:2009:ICS,
%Parfait:2008, Jovanovic:2006:Pixy, livshits05finding, Avots:2005:ISS,
%Shankar:2001:DFS,  Engler:2000:CSR}, 
%dynamic tools\cite{KMPS2011, Clause:2007:Dytan}, and
%hybrid tools\cite{Balzarotti:2008:SCS4}.
Each work can generally be characterized based on four main elements:
\begin{itemize}
  \item \textit{Technique}: static (interprocedural, context-sensitivity), dynamic, hybrid
  \item \textit{Input}: source code, binaries, annotations
  \item \textit{Language}: typed/untyped, managed/unmanaged
  \item \textit{Vulnerability Type}: user-dependent input, internal
\end{itemize}

The remainder of this section  focuses on taint analysis
(also called user-input dependence analysis) for finding
security vulnerabilities.

\subsection{Static Analysis}
Static analysis techniques are widely used for finding
security vulnerabilities in \cite{Tripp:2009:TAJ,
Kiezun:2009:Ardilla, Chang:2009:ICS, Parfait:2008,
Jovanovic:2006:Pixy, livshits05finding, Avots:2005:ISS,
Shankar:2001:DFS,  Engler:2000:CSR}. Tools in this category
suffer from the well known problems of static analysis:
\textit{undecidability} and \textit{scalability}.

Common techniques used to mitigate scalability issues
include the use of \textit{program slicing} and
\textit{demand-driven analysis}\cite{Reps:1995:PIC, Parfait:2008, Tripp:2009:TAJ},
and \textit{modular decomposition}\cite{Shankar:2001:DFS}.

\paragraph{Interprocedural Analysis}

\paragraph{Context-Sensitivity}

\subsection{Dynamic Analysis}
Dynamic analysis performs on running programs, and in general
do not need access to the source code of the program under analysis
\cite{Kiezun:2009:Ardilla, Clause:2007:Dytan, Balzarotti:2008:SCS4}.
A dynamic analysis is interprocedural and context-sensitive in
nature because it runs along with the analyzed program. 

A dynamic taint analysis instrument program memory locations
that correspond to taint sources, taint sinks, and where taint
propagation shall occur. For managed languages (e.g. Java, C\#),
developers may also choose to instrument programs at the level
of the virtual machine or runtime system. \cite{Livshits:2012:DTTMR}
provides a taxonomy on the topic. 
The major bottleneck of dynamic analysis lies in the execution
overhead that incurs the program instrumentation.

\textit{Forward symbolic execution} is a technique that builds
a logical formula to represent a program execution. The logical
formula enables developers to reason about different program input.
It is common to combine forward symbolic execution and dynamic
taint analysis. \cite{Schwartz:2010:YEW} discusses
this combination and possible implementation choices.
\end{comment}

\subsection{Static Analysis for Vulnerability Detection}


\textbf{Parfait} from Oracle Labs checks for bugs
in C programs~\cite{Parfait:2008}. \parfait is built on top
of LLVM and uses a demand driven analysis to mitigate
scalability issues inherent to standard forward dataflow
analysis techniques.	
\parfait does not require annotations from developers and
is advertised to scale to millions of lines of code. 
For security vulnerabilities, \parfait implements a taint
analysis~\cite{Scholz:2008:UDA} as pre-processing filter.
that is linear in the number of statements and dependencies.
\parfait's taint analysis is formulated as a graph reachability
problem. \parfait implements both a context-insensitive and
a context-sensitive solution for its taint-analysis, and 
adds a may-function alias analysis to LLVM to better support
the accuracy of the taint analysis.
Similarly to \parfait, \waint may also perform either a
context-insensitive or a context-sensitive analysis. \waint
is also based on LLVM, and do not require any annotations
from developers.
It is not possible to use a third party alias analysis with
\parfait. In contrast, \waint users have the possibility to
change the pointer analysis library it uses.\\

\textbf{Pixy} is a tool that statically scans for cross-site
scripting vulnerabilities in PHP scripts~\cite{Jovanovic:2006:Pixy}.
\pixy implements a flow-sensitive, context-sensitive dataflow analysis.
\pixy also creates and uses an alias and literal analysis for PHP.\\

Livshits et al. presents a tool for finding security
vulnerabilities in web applications written in Java~\cite{livshits05finding}.
The tool is based on \bddbddb~\footnote{http://suif.stanford.edu/bddbddb},
which automatically generates context-sensitive program analyzes
for specifications written in \datalog~\cite{Ullman:1988:datalog}.
\bddbddb uses binary decisions diagrams to represent and manipulate
points-to results for different contexts in a Java program. The authors
implement taint propagation on top of the points-to results generated
by \bddbddb.
In fact, developers specify vulnerabilities in the \pql
language~\cite{Martin:2005:PQL}, which is a syntactic sugar for \datalog. 
That is, each vulnerability specification corresponds to a set of
\pql queries.\\

\textbf{CQual} by Shankar et al. detects format string
vulnerabilities in C programs~\cite{Shankar:2001:DFS}.
\cqual's analysis is based on type qualifiers\cite{Foster:1999:TTQ}
and type inference. 
Given a C program, an initial subset of the program is annotated
with the type qualifiers \texttt{tainted} and \texttt{untainted}.
\cqual then uses a set of inference rules to generate type (qualifier)
constraints over the program. 
Pointer reasoning is done via some rules of the type system.
The analysis then warns the user of a format string vulnerability
whenever the program does not type checks due to an unsatisfiable
constraint. According to results published in~\cite{Shankar:2001:DFS},
\cqual performs on average $85$s for a code base of $20$k lines of code,
and takes $268$s to analyze the largest program of $43$k.
In contrast to \cqual, users of \waint may experiment with different pointer
analysis libraries and choose among them. \waint also do not require
any annotations.

\subsection{Dynamic Analysis for Vulnerability Detection}
\textbf{Dytan} is a framework that generates dynamic
taint analyzes for x$86$ binaries~\cite{Clause:2007:Dytan}.
\dytan does not need access or recompilation of program source code.
Developers specify an analysis by giving taint sources, taint sinks,
and a propagation policy. Taint sources can be variable names,
function-return values, and data read from I/O stream (e.g. file, 
network connection, etc.). Taint sinks are specified by memory or code
location. Sinks can also be based on usage scenarios (e.g. 
perform a check before execution of \texttt{jump} instructions).
Clause et al. report performance overhead op up to $30$ times
for data-flow propagation only. The slowdown goes up to $50$
times for combined control- and data-flow propagation.
In contrast, \waint is used during the development phase and
does not incur any performance slowdown during program execution.\\

\textbf{TaintCheck} by Newsome et al. implements a dynamic
taint analysis that relies on runtime emulation of
programs~\cite{Newsome:2005:taintcheck}. \taintcheck is
implemented as an extension of \valgrind~\cite{Nethercote:2003:valgrind}
and detects vulnerability exploits at the time tainted data is used
by the program. \taintcheck does not require access or special
compilation of application source code. The analyzed program is
instrumented at runtime, and the taint analysis code allocates
a data structure for each identified tainted data.
Each allocated data structure records a copy of the tainted data,
a snapshot of the current stack, and a system call number when
the tainted data originates from a system call. Each byte of memory
(e.g. registers, stack, etc.) has a four-byte shadow memory
that stores a pointer to a tainted data structure if that memory
location is tainted or a NULL in case of an untainted location.
The paper argues that \taintcheck is able to detect previously
unknown exploit attacks, and automatically create corresponding
signatures.
\taintcheck is meant to be an emulation container for a running
application, and thus incurs some performance overhead. The authors
of \taintcheck reports slowdown of up to $40$ times for their
benchmark programs.
On the other hand, \waint is meant to detect vulnerabilities
during the development phase of an application, does not incur
any performance overhead at program runtime.\\

\textbf{Libsafe $2.0$} by Avaya Labs is a library
that detects and avoids some instances of format string
vulnerabilities~\cite{Tsai:2001:libsafe}. 
\libsafe operates in three steps: interception, safety check,
and violation handling. 
The installation of \libsafe automatically redirects all calls
to functions of the C standard library to their equivalent
\libsafe functions.
Once a function call is intercepted, \libsafe checks call
arguments and either executes the original C function
(e.g. \texttt{sprintf}), or calls its safer alternative
(e.g. \texttt{snprintf}).
\libsafe applies a special handling for functions
\texttt{IO\_vfprintf()} and \texttt{IO\_vfscanf()} on which
all other *\texttt{printf} and *\texttt{scanf} functions rely.
For these two functions, \libsafe checks that the associated
pointer argument of each \%n specifier do not point to
a return address or frame pointer.
\libsafe also checks that all call arguments of the function
are contained within a single stack frame. If any of these
checks fails, then \libsafe found a violation.
\libsafe handles violation by terminating the running process.
There are few exceptions where \libsafe may authorize further
execution of the process.
For a proper behavior, \libsafe $2.0$ requires special
compilation of programs and usage of some specific C
libraries. The paper does not report the performance
slowdown incur by \libsafe usage.

\subsection{Hybrid Analysis for Vulnerability Detection}
 \cite{Trip:2011:HAJSA}

\subsection{Symbolic Execution for Vulnerability Detection}

\paragraph{\ardilla} by Kie{\.z}un et al. is a tool that uses
concolic execution to automatically create input leading to
SQL injection and cross-site scripting attacks for web
applications written in PHP~\cite{Kiezun:2009:Ardilla}.
\ardilla does not require any annotations. Developers
define a time limit within which \ardilla attempts to
create input data that exercise security vulnerabilities
present in the application. For that, \ardilla uses an input
generator to create new input for the application.
During application execution, the input generator records path
constraints that capture the control-flow paths taken by
that specific execution. The input generator then automatically
and iteratively creates new input data by negating the
obtained path constraints.
The web application then runs with the newly created
input data and flows along program paths different from
previous executions. The input data generation continues
until all program paths are covered or the time limit set
by the developer exceeds.
During program executions triggered by the input generator,
\ardilla tracks tainted values. More importantly, \ardilla
also tracks tainted values that are stored into the database.
That is, tainted values stored into the database are also
marked as tainted at their retrieval.

\subsection{Comparison}

%Taint Analysis for managed languages