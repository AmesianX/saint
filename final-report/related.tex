\newcommand{\parfait}{\texttt{Parfait}\xspace}
\newcommand{\cqual}{\texttt{CQual}\xspace}

\begin{table*}[!htbp]
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
{\bf Name} & {\bf Language}	& {\bf Technique } &	{\bf Annotation}	& {\bf Context-Sensitive} & {\bf Input}  \\ \hline
Parfait	    &	C, C++		&	DD,	static		&						&	Yes					&							\\
CQual	 	&	C			&	TS, static		&	Yes					&						&   						\\
Archer	 	&	C			&	SA				&						&						&   						\\
Splint		&	C			&					&	Yes					&						&							\\
Jlint		&	Java		&	DF, AI			&						&						&							\\
Safer		&				&					&	Yes					&						&							\\
Coverity	& C, C++, Java  &					&						&						&							\\
VeraCode	& C, C++, Java  &					&						&						&	Binaries				\\
Klocwork	& C, C++, Java  &	IDF				&						&						&							\\
Pixy		&				&					&						&						&							\\ \hline
\end{tabular}\caption{Program Analysis Tool for Security}
\end{table*}

\section{Related Work}\label{sec:related}

\subsection{Static Analysis}

\cite{Engler:2000:CSR}

\subsection{Dynamic Analysis}

\subsection{Static Analysis for Vulnerability Detection}

\parfait\cite{Parfait:2008} is a tool for finding bugs in
C programs. \parfait is built on top of LLVM and employs
demand-driven algorithms to mitigate scalability issues
inherent to standard forward dataflow analysis techniques
and to static analysis in general.	
\parfait does not require annotations from developers and
is advertised to scale to millions of lines of code. 
Specifically for security vulnerabilities, \parfait implements
a user-input dependence analysis\cite{Scholz:2008:UDA} (i.e taint analysis) that
is linear in the number of statements and dependencies. \parfait's
user-input dependence analysis is formulated as a graph
reachability problem. It implements both a context-insensitive and
a context-sensitive approach. The authors of \parfait added 
a may-function alias analysis to LLVM to better support
the accuracy of the user-dependence analysis.\\

\cqual\cite{Shankar:2001:DFS} detects format string vulnerabilities
in C programs. \cqual's analysis is based on type
qualifiers\cite{Foster:1999:TTQ} and type inference. Given a C program,
an initial subset of the program is annotated with the type qualifiers
\texttt{tainted} and \texttt{untainted}. \cqual then uses a set of
inference rules to generate type (qualifier) constraints over the program.
The analysis then warns the user of a format string vulnerability
whenever the program does not type checks due to an unsatisfiable
constraint. According to results published in \cite{Shankar:2001:DFS},
\cqual performs on average $85$s for a code base of $20$k lines of code.
It took $268$s to analyze the biggest program of $43$k.

\subsection{Dynamic Analysis for Vulnerability Detection}

\subsection{Type System Based Vulnerability Detection}

\subsection{Comparison}

%Taint Analysis for managed languages