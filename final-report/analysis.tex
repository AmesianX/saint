\section{Interprocedural Analysis}\label{analysis}

We implemented our analysis as a fixed-point iteration
over the set of program statements. Our analysis performs
on the interprocedural control flow graph (ICFG) of the program.
Intraprocedural flow edges are gathered from each function
control flow graph, while interprocedural flow edges are
gathered from the program call graph built by LLVM. 

Our analysis dataflow set is $VarTaint \times Inst$,
where $VarTaint \subset Var$ is the set of tainted program
variables and $Inst$ the set of program statements. 
$Var$ represents the set of all program variables.
At a program point $p_n$, a dataflow set is composed
of a set of pairs $(v, S_v)$, where $v$ is a tainted
variable, and $S_v$ the set of statements where $v$
has been used before the $p_n$.
 
\subsection{Analysis algorithm} 
\begin{table}
\begin{tabular}{|l|l|}
\hline
\textbf{Symbols}	&	\textbf{Description}							\\ \hline
$\mathit{D}$		&	$\mathit{Var} \rightarrow 2^\mathit{Inst}$		\\
					&	Analysis dataflow set 							\\ \hline
$\mathit{Proc}$		&	Set of all program functions and procedures 	\\ \hline
$\mathit{Inst}$		&	Set of instructions in the program 				\\ \hline
$\mathit{inFlow}$	&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 		\\
					&	Function that returns the dataflow values		\\
		    		&	at the program point before an instruction 		\\ 	\hline
$\mathit{outFlow}$	&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 		\\
					&	Function that returns the dataflow values		\\
		    		&	at the program point after an instruction 		\\ 	\hline
$\mathit{taintUse}$	&	$\mathit{Var}\ \rightarrow\ 2^{Inst}$ 				\\
					&	Function that returns program statements where	\\
		    		&	a tainted variable has been used	 			\\ 	\hline		    		
$\mathit{worklist}$	&	Set of remaining instructions to be processed 	\\ \hline
$\mathit{Flow}$		&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 		\\
					&   Analysis flow function (Algorithm~\ref{fig:algoFlow}) 			\\ \hline
$\mathit{first}$	&	$\mathit{Func} \rightarrow\ \mathit{Inst}$ 		\\
					& 	Function that returns the first instruction		\\
					&	of a procedure									\\ \hline
$\mathit{next}$		&	$\mathit{worklist}\ \rightarrow\ \mathit{Inst}$ \\
					& 	Function that returns the next instructions		\\
					&	from the worklist								\\ \hline
$\pointsto{s}{q}$	&	Set of program locations to which variable q	\\
					&	may point to at the program statement $s$		\\
					& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline					
\end{tabular}
\caption{Algorithm Symbols}\label{symTable}
\end{table}

Algorithm~\ref{fig:algoAnalyze} represents the pseudo code of
our analysis algorithm\footnote{Adapted from Jonathan Aldrich's
lecture notes} \texttt{Analyze}, and Table~\ref{symTable}
describes the symbols we use.

\IncMargin{1em}
\begin{algorithm}
\caption{Analyze}\label{fig:algoAnalyze}
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{func}{f}
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Output}{output}
\SetKwFunction{InFlow}{inFlow}
\SetKwFunction{OutFlow}{outFlow}
\SetKwFunction{Flow}{Flow}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwFunction{AnalyzeAlgo}{Analyze}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Func: \mathit{Proc}, \newline
		 \InitDataFlow: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst})$}
\OutData{}
%\Input: VarTaint \rightarrow Inst, \newline
%\OutData{$\Output: VarTaint \rightarrow Inst$}
$ s_0 \leftarrow first(\func)$\;
$\Input[s_0] \leftarrow \InitDataFlow(s_0)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ \neq\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] \leftarrow \Flow(\AnalyzeAlgo, \varI)$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] \leftarrow \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist \leftarrow \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm}
\DecMargin{1em}

We define a set of C standard library functions that
we considered as sources. These library functions are not
further analyzed during \texttt{Analyze}'s run.
Instead we provide for them annotations that specify
which of their parameters becomes tainted after they
have run. Appendix !!! lists the C standard library
functions the analysis considers as sources.

On the other hand, we also predefine a set of functions
we consider as sinks. These functions are handled similarly
to the previous described sources. Appendix !!! lists
the C standard library functions the analysis considers
as sinks.

\IncMargin{1em}
\begin{algorithm*}
\caption{Flow}\label{fig:algoFlow}
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \newline
		 \stmt: \mathit{Inst}$}
%\OutData{$\Output: \mathit{Var} \rightarrow \mathit{Inst}$}
\OutData{}
%$\Output \leftarrow \Input$\;
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtQ] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA \in \pointsto{\overline{\stmt}}{q}$}{
			\If{$\Input[\stmtA] \neq \emptyset$}{	
				$\Output[\stmtP] \leftarrow \Input[\stmtP] \cup \set{\stmt}$\;			
			}
		}
	}	
	\uCase{$\LSINK\ [\Func(a_0, a_1, ..., a_n)]$}{
	}
	\Case{$\LSOURCE\ [\Func(a_0, a_1, ..., a_n)]$}{
		\ForEach{$\stmtA_k, k \in \set{0, 1, ..., n}$}{
			\If{$\Input[\stmtA_k] \in \mathcal{A}$}{			
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k] \cup \set{\stmt}$\;
			}
			\ElseIf{$\Input[\stmtA_k] \in \mathcal{P}$}{
				\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
					$\Output[\stmtB] \leftarrow \Input[\stmtB] \cup \set{\stmt}$\;						
				}			
			}			
		}
	}	
	\Case{$\LCALL\ [call\ \Func]$}{
		\If{$\Caller \neq \Func$}{
			$\Output \leftarrow \Flow(\Caller, \Func, \Input)$
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}
	\Case{$\LSTORE\ [*p = q] $}{
		%\If{$\Input[q] \neq \emptyset$}{
		%	\ForEach{$\stmtA \in \pointsto{\overline{\stmt}}{p}$}{
		%		$\Output[\stmtA] \leftarrow \Input[\stmtA] \cup \set{\stmt}$\;						
		%	}
		%}
	}	
}
\end{algorithm*}
\DecMargin{1em}

Function \texttt{Flow} (Algorithm~\ref{fig:algoFlow})
implements the analysis' transfer equations.

\subsection{Recursive and Mutual Recursive Function Calls} 

Our analysis ignore recursive functions calls: the dataflow set
before and after recursive calls are identical. 

We detect recursive mutual function calls by finding strongly
connected components of the ahead-of-time call graph generated
by LLVM. 

\subsection{Context-Sensitivity} 

We achieve context-sensitivity by analyzing callees
with dataflow set information of their formal parameters
at calling sites.

For instance in Figure~\ref{fig:sample}, the call to \even{} at
line $4$ would take into the account the fact that \texttt{x}
is tainted.
On the other hand, \even{}'s call at line $25$ can not safely
make this assumption.

\subsection{Motivating Example Case Study}\label{sec:sampleSummary}

\subsection{Handling of complex data structures}
