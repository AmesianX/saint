\section{Interprocedural Analysis}\label{analysis}

We implemented our analysis as a fixed-point iteration
over the set of program statements. Our analysis performs
on the interprocedural control flow graph (ICFG) of the program.
Intraprocedural flow edges are gathered from each function
control flow graph, while interprocedural flow edges are
gathered from the program call graph built by LLVM. 

Our analysis dataflow set is $VarTaint \times Inst$,
where $VarTaint \subset Var$ is the set of tainted program
variables and $Inst$ the set of program statements. 
$Var$ represents the set of all program variables.
At a program point $p_n$, a dataflow set is composed
of a set of pairs $(v, S_v)$, where $v$ is a tainted
variable, and $S_v$ the set of statements where $v$
has been used before the $p_n$.
 
\subsection{Analysis algorithm} 

\begin{table}
\begin{tabular}{|l|l|}
\hline
\textbf{Symbols}	&	\textbf{Description}							\\ \hline
$D$					&	Analysis dataflow set 							\\ \hline
$Inst$				&	Set of instructions in the program 				\\ \hline
$input$				&	$Inst\ \rightarrow\ D$ 							\\
					&	Function that returns the dataflow values		\\
		    		&	at the program point before an instruction 		\\ 	\hline
$output$			&	$Inst\ \rightarrow\ D$ 							\\
					&	Function that returns the dataflow values		\\
		    		&	at the program point after an instruction 		\\ 	\hline
$worklist$			&	Set of remaining instructions to be processed 	\\ \hline
$Flow$				&	$Inst\ \rightarrow\ D$ 							\\
					&   Analysis flow function (Algorithm~\ref{fig:algoFlow}) 			\\ \hline
$next$				&	$worklist\ \rightarrow\ Inst$ 					\\
					& 	Function that returns the next instructions		\\
					&	from the worklist.								\\ \hline
\end{tabular}
\caption{Algorithm Symbols}\label{symTable}
\end{table}

Algorithm~\ref{fig:algoAnalyze} shows the pseudo code of our
analysis algorithm\footnote{Adapted from Jonathan Aldrich's
lecture notes} \texttt{Analyze}, and table~\ref{symTable}
describes the symbols we use.

\begin{algorithm}
\caption{Analyze}\label{fig:algoAnalyze}
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{func}{f}
\SetKwData{Input}{input}
\SetKwData{Output}{output}
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Ouput}{output}
\SetKwFunction{Flow}{Flow}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\func: Proc, \Input: D, \InitDataFlow: Inst \rightarrow D$}
\OutData{$\Output: D$}
$ s_0 \leftarrow first(\func)$\;
$\Input[s_0] \leftarrow \InitDataFlow(s_0)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ !=\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] = \Flow(\varI, \Input[\varI])$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] = \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist = \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm}
\DecMargin{1em}

\texttt{Analyze} starts by storing the initial dataflow
set before the first program instruction $s_0$ and then
adds $s_0$ to the statement work list (\texttt{worklist}).
The initial dataflow set of the program points is obtain
through 
Then the program loops between line $4$ and $12$ until
the statement work list becomes empty.

For each loop, a statement $i$ is removed from
\texttt{worklist} and passed to the \texttt{Flow} function
with the dataflow set at the program point before $i$ (\texttt{input[i]}).
The function \texttt{Flow} returns the dataflow set for
the program point after statement $i$ (\texttt{output[i]}).

For each successor statement $j$ of $i$, if the new
dataflow set at $j$'s entry $j$ (\texttt{output}$[i]$)
is not smaller than the previous calculated set
(\texttt{output}$[i]\ \not\sqsubseteq\ $ \texttt{input}$[j]$),
\texttt{input}$[j]$ is updated and $j$ added to \texttt{worklist}.
On the other hand, if $j$ is not added to the work list, then
a fixed point has been reached at the program point before $j$.

This process is repeated until the statement work list
becomes empty, which means the analysis reached a
fixed point since no dataflow set changes again.

\IncMargin{1em}
\begin{algorithm}
\caption{Flow}\label{fig:algoFlow}
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Input}{input}
\SetKwData{Output}{output}
\SetKwData{stmt}{inst}
\SetKwData{stmtV}{v}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{Type}{Type}
\SetKwFunction{Update}{Update}
\SetKwFunction{Analyze}{Analyze}
%\SetKwFunction{FindCompress}{FindCompress}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\stmt: Inst, \Input: D$}
\OutData{$\Output: D$}
\Switch{$\Type(\stmt)$}{
	\uCase{$\LCOPY\ [p = q]$}{
		$\Output \leftarrow \Input \cup \set{(p, \set{\stmt})}$\;
	}
	\uCase{$\LLOAD\ [p = *q]$}{
		\ForEach{$\stmtV \in \pointsto{\stmt}{q}$}{
			$S_{v} \leftarrow \Input[\stmtV]$\;		
			$\Output \leftarrow \Input \cup \set{(\stmtV, S_v \cup \stmt)}$\;
		}
	}
%	\Case{$\mathbb{ADDROF}\ [p = \&a]$}{
%	}
	\uCase{$\LSTORE\ [*p = q]$}{
		\ForEach{$\stmtV \in \pointsto{\stmt}{p}$}{
			$S_{v} \leftarrow \Input[\stmtV]$\;
			$\Output \leftarrow \Input \cup \{ (\stmtV, S_{v} \cup \stmt) \}$\;
		}
	}	
	\uCase{$\LCALL\ [call\ f]$}{
		$\Output \leftarrow Analyze(f, \Input)$
	}		
	\Other{
		$\Output \leftarrow \Input$
	}
}
\end{algorithm}
\DecMargin{1em}

Function \texttt{Flow} (Algorithm~\ref{fig:algoFlow})
implements the analysis' transfer equations.
For a pointer variable $q$, we define $\pointsto{s}{q}$
as the set of program locations to which q may point
to at the program statement labelled with $s$
(i.e $q$'s \textit{points-to set} at statement $s$).

\texttt{input}$[s]$ and \texttt{output}$[s]$ represent
the dataflow set \textit{before} and \textit{after}
statement $s$ respectively. 

For a tainted variable $t$, $S_t$ is the set of previous
statements which use $t$ as tainted variable.

\subsection{Context-Sensitivity} 

We achieve context-sensitivity by analyzing callees
with dataflow set information of their formal parameters
at calling sites.

For instance in Figure~\ref{fig:sample}, the call to \even{} at
line $4$ would take into the account the fact that \texttt{x}
is tainted.
On the other hand, \even{}'s call at line $25$ can not safely
make this assumption.

\subsection{Motivating Example Case Study}\label{sec:sampleSummary}

\subsection{Handling of complex data structures}
