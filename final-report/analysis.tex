\section{Staged Analysis}\label{sec:analysis}

\newcommand{\Aset}{\mathcal{A}}
\newcommand{\Pset}{\mathcal{P}}
\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\procset}{\mathit{Proc}}
\newcommand{\formalsset}{\mathit{formals}}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\myoutflow}{\mathit{OUT}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

\newcommand{\copydef}{$\text{COPY}\ [p = q]$}
\newcommand{\loaddef}{$\text{LOAD}\ [p = *q]$}
\newcommand{\addrofdef}{$\text{ADDROF}\ [p = \&a]$}
\newcommand{\storedef}{$\text{STORE}\ [*p = q]$}
\newcommand{\sourcedef}{\text{SOURCE}\ [r = \text{call}\ \text{func}(a_0, a_1, ..., a_n)]}
\newcommand{\calldef}{\text{CALL} [r = \text{call}\ \text{func}(a_0, a_1, ..., a_n)]}
\newcommand{\callinsdef}{\text{CALL-INS} [r = \text{call}\ \text{func}(a_0, a_1, ..., a_n)]}
\newcommand{\sinkdef}{\text{SINK} [r = \text{call}\ \text{func}]}

Our taint analysis is interprocedural and can be run
either context-insensitively or context-sensitively.
Either of the interprocedural analyses is always preceded
by an intraprocedural analysis. The intraprocedural analysis
computes initial data flow sets that are reused by the
interprocedural analyses.
The analysis builds and maintains a summary table that contains
taint information about program procedure formal parameters
and return value.
The initial values of the summary table are written by
the intraprocedural analysis. The use of a summary table
allows a fast access to key information about procedures.
This is especially useful during the subsequent interprocedural
phases.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample}, which also contains the return
value of \compute{}, may be tainted due to the call
to \texttt{scanf} at line $13$.
Appendix~\ref{app:algo} presents pseudo code for all
our analysis algorithms.

Our analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program statements where $v$ might be tainted.
If $v$ might not be tainted before statment $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

\paragraph{Formalisms}
We use the following elements to describe our analysis:
$\procset$ is the set of all program functions and procedures,
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function or procedure,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function or procedure, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before a corresponding statement s,
and $\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after a corresponding statement s.
\begin{comment}
\begin{figure*}
\[
\begin{array}{lcl}
	\myoutflow[p] & = & \emptyset,\   \addrofdef	\\
		
	\myoutflow[r] & = & \emptyset,\   \sinkdef	\\
			
	\myoutflow[p] & = & \set{s},\   \copydef	\\
				
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{q}}{} \myinflow{}_s[t_k]\, t_k =\ \mathit{toplevel(a_k)},\   \loaddef	\\		
			
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{p}}{} \myinflow{}_s[t_k] \cup \myinflow{}_s[q]\, t_k =\ \mathit{toplevel(a_k)},\
	   \storedef	\\
	   
	\myoutflow[p] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ \text{taint}(f_k) \equiv\ 
	\text{true},\   \sourcedef	\\
	
	\myoutflow[r] & = & \myinflow{}_s[r] \cup \set{s},\ \text{summaryTable}[\text{func}][n+1] \equiv\ 1,\	\callinsdef	\\							

	\myoutflow[a_k] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ 
		\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\callinsdef	\\							
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[b] & = & \mybigcup{b \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\			
\end{array}
\]
\caption{Transfer Equations}
\end{figure*}
\end{comment}
\paragraph{Pointer Analysis}
Our analysis is designed to work by using the results of
a prior computed pointer analysis. This may enable us to
do various experimentations with different types of pointer
analyses. For this project, we choose to use a hybrid
pointer analysis \cite{Lhotak:2011:PAE}. \lothak{} at al.'s
pointer analysis attempts to benefit from the
advantages of both flow-insensitive and flow-sensitive 
pointer analyses. It is implemented as an extension of
Andersen's interprocedural flow-insensitive analysis, but
produces additional flow-sensitive information. The analysis'
algorithm relies on the observation that strong updates
are only possible whenever an abstract pointer location is
a singleton set. Therefore the analysis works as a
flow-insensitive analysis, but applies flow-sensitive
rules whenever an abstract pointer location is a singleton set.
The evaluation results of the paper show that the performance
of the strong update analysis is comparable to that of a
flow-insensitive analysis. The results also show that the hybrid
analysis provides the same benefits as a fully flow-sensitive
analysis at $98\%$ of stores and loads in the program.

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse topological
order of the call graph.
The intraprocedural analysis works on each function body and
do not take into account interprocedural control flow.
The computed data flow sets are reused later on by the
subsequent interprocedural analyses. In particular, taint
information about procedure formal parameters and return value
is kept in a global summary table.
All tainted variables due to source functions are found by
the intraprocedural analysis. 
For instance, the intraprocedural analysis detects that variable
\texttt{sum} of procedure \compute{} of our running example
(Figure~\ref{fig:sample}) may be tainted due to the call
to \texttt{scanf} at line $13$.
the intraprocedural analysis always run first, before the
interprocedural context-insensitive or context-sensitive
analyses.

\paragraph{Context-Insensitive Analysis}
Our context-insensitive analysis is performed
in the topological order of the call graph, and uses
results from the intraprocedural analysis whenever
available. Taint assumptions about callee actual
parameters at call sites are done based on the value
present in the summary table. The analysis itself does not
attempt to propagate flow set values from the caller
to the callee.
For instance, the intraprocedural analysis of function
\main{} marks variable \texttt{x} as tainted in the
summary table. This is information is then reused by
the context-insensitive analysis when it reaches the
call site at line $6$ of \main{}.
During the subsequent analysis of \main{}, the fact that
variable \texttt{y} gets tainted at line $6$ is known
directly from the summary table information written
by \compute{}. This can then be reused for further
taint propagation.

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the intraprocedural analysis. If the
context-insensitive analysis was run before, the context-sensitive
analysis eventually finds more precise information in the summary
table.
At call sites, the context-sensitive analysis propagates
actual parameters' taint information from the caller to the
callee. At callees' exit, newly computed taint information
are propagated back from the callee to the caller context.
Algorithm~\ref{fig:csInterFlow} in Appendix~\ref{app:algo}
presents our context-sensitive algorithm in detail.

\paragraph{Recursive and Mutual Recursive Function Calls} 
Our analysis ignores recursive function calls: the dataflow set
before and after recursive calls is identical.
We detect recursive mutual function calls by finding strongly
connected components (SCC) in the call graph generated by LLVM.

There is no particular treatment of mutual recursive function
calls during the context-insensitive analysis. Only the
procedure information from the summary table is used.

On the other hand, functions on the call graph that builds a
SCC are analyzed together suring the context-sensitive analysis.
That is, when a call to one function of a SCC happens,
the analysis starts from that function and propagates taint
information at call sites of all other functions in the SCC set,
but each function is analyzed once.

\paragraph{Complex Data Structures}
