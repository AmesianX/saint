\section{Staged Taint Analysis}\label{sec:analysis}

\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\procset}{\mathit{Proc}}
\newcommand{\formalsset}{\mathit{formals}}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\myoutflow}{\mathit{OUT}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

Our taint analysis is interprocedural and can be run
either context-insensitively or context-sensitively.
Either of the interprocedural analyses is always preceded
by an intraprocedural analysis. The intraprocedural analysis
computes initial data flow sets that are reused by the
interprocedural analyses.
The analysis constructs a summary table which contains
taint information about program procedure's formal
parameters and return value.
The initial values of the summary table are written by
the intraprocedural analysis. The use of a summary table
allows fast access to key information about procedures.
This is especially useful during the subsequent interprocedural
phases.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample}, which also holds the return
value of \compute{}, may be tainted due to the call
to \texttt{scanf} at line $13$.
Appendix~\ref{app:algo} presents pseudo code for all
our analysis algorithms.

\paragraph{Taint Sources and Sinks}

\paragraph{Taint Propagation}

\paragraph{Formalisms}
Our analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program tainting statements.
If $v$ is definitely not tainted before statement $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

We use the following elements to describe our analysis:
$\varset$ is the set of all program variables,
$\procset$ is the set of all program functions and procedures\footnote{We
will use the terms function and procedure interchangeably in
the remainder of this paper.},
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before the statement labelled s,
and $\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after the statement labelled s.
\begin{comment}
\begin{figure*}
\[
\begin{array}{lcl}
	\myoutflow[p] & = & \emptyset,\   \addrofdef	\\
		
	\myoutflow[r] & = & \emptyset,\   \sinkdef	\\
			
	\myoutflow[p] & = & \set{s},\   \copydef	\\
				
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{q}}{} \myinflow{}_s[t_k]\, t_k =\ \mathit{toplevel(a_k)},\   \loaddef	\\		
			
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{p}}{} \myinflow{}_s[t_k] \cup \myinflow{}_s[q]\, t_k =\ \mathit{toplevel(a_k)},\
	   \storedef	\\
	   
	\myoutflow[p] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ \text{taint}(f_k) \equiv\ 
	\text{true},\   \sourcedef	\\
	
	\myoutflow[r] & = & \myinflow{}_s[r] \cup \set{s},\ \text{summaryTable}[\text{func}][n+1] \equiv\ 1,\	\callinsdef	\\							

	\myoutflow[a_k] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ 
		\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\callinsdef	\\							
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[b] & = & \mybigcup{b \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\			
\end{array}
\]
\caption{Transfer Equations}
\end{figure*}
\end{comment}
\paragraph{Pointer Analysis}
Our analysis is designed to work using the results of
a previously computed pointer analysis. This would enable us to
do experiments with different types of pointer
analyses. For this project, we choose to use a hybrid
pointer analysis \cite{Lhotak:2011:PAE}. The hybrid
pointer analysis attempts to benefit from the
advantages of both flow-insensitive and flow-sensitive 
pointer analyses. It is implemented as an extension of
Andersen's interprocedural flow-insensitive analysis, but
additionally produces flow-sensitive information. The analysis
algorithm relies on the observation that strong updates
are only possible whenever an abstract pointer location is
a singleton set. Therefore the analysis works as a
flow-insensitive analysis, but applies flow-sensitive
rules whenever an abstract pointer location is a singleton set.
The evaluation of the hybrid pointer analysis shows that its
strong update analysis runs about as fast as a flow-insensitive analysis.
The results also show that the hybrid
analysis provides the same benefits as a fully flow-sensitive
analysis at $98\%$ of stores and loads in the program.

\paragraph{Taint Propagation}

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse
topological order of the call graph (i.e starting
from the leaves of the callgraph).
The intraprocedural analysis works on each function
body and do not take into account interprocedural
control flow. The computed data flow sets are reused
later on by the subsequent interprocedural analyses.
In particular, taint information about function
formal parameters and return value is kept in a
global summary table.
All tainted variables due to source functions are
found by the intraprocedural analysis. 
For instance, the intraprocedural analysis detects
that variable \texttt{sum} of function \compute{}
in Figure~\ref{fig:sample} may be tainted due to the
call to \texttt{scanf} at line $13$.
The intraprocedural analysis always runs
first, before the interprocedural context-insensitive
or context-sensitive analyses.
The pseudo code for the intraprocedural analysis
is showed in Algorithm~\ref{fig:intraFlow}.

\paragraph{Context-Insensitive Analysis}
The context-insensitive analysis starts from the
\textit{main function} (entry point of the program) and
performs in the topological order of the call graph.
It uses function return value taint assumptions from the
intraprocedural analysis and applies them whenever available.
The context-insensitive analysis does not attempt
to propagate flow set values from the caller to the callee.
It only updates flow set values of function returns
(computed during the intraprocedural run) and further
propagates taint information.
For instance, the intraprocedural analysis of function
\main{} marks the return value of \compute
(stored in variable \texttt{sum}) as tainted in the summary
table. At line $6$ of \main, the context-insensitive analysis 
would take into account that the return value of \compute
is stored into variable \texttt{y}. Thus, \texttt{y}
becomes a tainted variable.
Algorithm~\ref{fig:interFlow} in Appendix~\ref{app:algo}
illustrates the context-insensitive algorithm.

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the intraprocedural analysis. If the
context-insensitive analysis was run before, the context-sensitive
analysis eventually finds more precise information in the summary
table.
At call sites, the context-sensitive analysis propagates
actual parameters' taint information from the caller to the
callee. At callees' exit, newly computed taint information
are propagated back from the callee to the caller context.
Algorithm~\ref{fig:csInterFlow} in Appendix~\ref{app:algo}
presents our context-sensitive algorithm in detail.

\paragraph{Recursive and Mutual Recursive Function Calls} 
Our analysis ignores recursive function calls: the dataflow set
before and after recursive calls is identical.
We detect recursive mutual function calls by finding strongly
connected components (SCC) in the call graph generated by LLVM.

There is no particular treatment of mutual recursive function
calls during the context-insensitive analysis. Only the
procedure information from the summary table is used.

On the other hand, functions on the call graph that builds a
SCC are analyzed together during the context-sensitive analysis.
That is, when a call to one function of a SCC happens,
the analysis starts from that function and propagates taint
information at call sites of all other functions in the SCC set,
but each function is analyzed once.

\paragraph{Complex Data Structures}

We are not handling complex data structures in this project.
However, we plan to report the usage of tainted C structures
(\texttt{struct}) and arrays in future work.