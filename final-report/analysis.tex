\section{Analysis}\label{stagedAnalysis}

\newcommand{\Aset}{\mathcal{A}}
\newcommand{\Pset}{\mathcal{P}}
\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\procset}{\mathit{Proc}}
\newcommand{\formalsset}{\mathit{formals}}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

\newcommand{\copydef}{$\text{COPY}\ [p = q]$}
\newcommand{\loaddef}{$\text{LOAD}\ [p = *q]$}
\newcommand{\addrofdef}{$\text{ADDROF}\ [p = \&a]$}
\newcommand{\storedef}{$\text{STORE}\ [*p = q]$}
\newcommand{\sourcedef}{$\text{SOURCE}\ [r = \text{call}\ \text{func}(a_0, a_1, ..., a_n)]$}
\newcommand{\calldef}{$\text{CALL} [r = \text{call}\ \text{func}(a_0, a_1, ..., a_n)]$}
\newcommand{\sinkdef}{$\text{SINK} [r = \text{call}\ \text{func}]$}

Our taint analysis is interprocedural and can be run
either context-insensitively or context-sensitively.
Our analysis builds and uses a summary table that contains
taint information about program procedure formal parameters
and return value.
The initial values of the summary table are written by
an intraprocedural analysis that runs prior to any variant
of the interprocedural analysis. The use of a summary table
enables the reuse of information by successive analyses.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample} may be tainted due to the call
to \texttt{scanf} at line $13$. This information is then
reused by the subsequent interprocedural analyses.

Our analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program statements where $v$ might be tainted.
If $v$ might not be tainted before statment $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

We further use the following elements to describe our analysis:
$\procset$ is the set of all program functions and procedures,
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function or procedure,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function or procedure, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before a corresponding statement s,
and $\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after a corresponding statement s.

\begin{figure*}
\[
	\mathit{GEN}(s)	=	
	\begin{cases}
		\emptyset,	&\text{if $s$ is a \addrofdef}	\\
		
		\emptyset,	&\text{if $s$ is a \sinkdef}	\\
			
		\set{s},	&\text{if $s$ is a \copydef}	\\
				
		\mybigcup{a_k \in\ \pointsto{s}{q}}{} \myinflow{}_s[t_k]\ \text{where}\ t_k =\ \mathit{toplevel(a_k)},
			&\text{if $s$ is a \loaddef}	\\		
			
		\mybigcup{a_k \in\ \pointsto{s}{p}}{} \myinflow{}_s[t_k] \cup \myinflow{}_s[q]\ \text{where}\ t_k =\ \mathit{toplevel(a_k)},	
			&\text{if $s$ is a \storedef}	\\
			
		\mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s}\ \text{where}\ \text{taint}(f_k) \equiv\ \text{true},	
			&\text{if $s$ is a \sourcedef}	
	\end{cases}
\]
\[	
	\mathit{GEN}(s) =
	\begin{cases}			
		\mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\ \text{where}\ \text{summaryTable}[\text{func}][f_k] \equiv\ 1,	
			&\text{if $s$ is a \calldef}	\\							
		\mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\ \text{where}\ \text{summaryTable}[\text{func}][f_k] \equiv\ 1,	
			&\text{if $s$ is a \calldef}								
	\end{cases}
\]
\caption{Gen Sets}
\end{figure*}

\paragraph{Pointer Analysis}
Our analysis is designed to work by using the results of
a prior computed pointer analysis. This may enable us to
do various experimentations with different types of pointer
analyses. For this project, we choose to use a hybrid
pointer analysis \cite{Lhotak:2011:PAE}. \lothak{} at al.'s
pointer analysis attempts to benefit from the
advantages of both flow-insensitive and flow-sensitive 
pointer analyses. It is implemented as an extension of
Andersen's interprocedural flow-insensitive analysis, but
produces additional flow-sensitive information. The analysis'
algorithm relies on the observation that strong updates
are only possible whenever an abstract pointer location is
a singleton set. Therefore the analysis works as a
flow-insensitive analysis, but applies flow-sensitive
rules whenever an abstract pointer location is a singleton set.
The evaluation results of the paper show that the performance
of the strong update analysis is comparable to that of a
flow-insensitive analysis. The results also show that the hybrid
analysis provides the same benefits as a fully flow-sensitive
analysis at $98\%$ of stores and loads in the program.

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse topological
order of the call graph.
The intraprocedural analysis works on each function body and
do not take into account interprocedural control flow.
Once it detects that a tainted value is written to a variable,
it writes this information to the summary table. The
information from the summary table is used in later stages
by the interprocedural analyses.
For instance, all tainted variables due to source functions
are found by the intraprocedural analysis.
For instance, the intraprocedural analysis detects that variable
\texttt{sum} of procedure \compute{} of our running example
(Figure~\ref{fig:sample}) may be tainted due to the call
to \texttt{scanf} at line $13$.
Developers can choose between an interprocedural context-insensitive
or context-sensitive analysis. However, the intraprocedural
analysis always run first. 

\paragraph{Context-Insensitive Analysis}
Our context-insensitive analysis is performed
in the reverse topological order of the call graph,
and uses results from the intraprocedural analysis
stored in the summary table whenever available.
Taint assumptions about callee actual paramneters
at call sites are done based on the values present
in the summary table. The analysis itself does not
attempt to propagate flow set values from the caller
to the callee.
For instance, the intraprocedural analysis of function
\main{} marks variable \texttt{x} as tainted in the
summary table. This is information is then used by
the context-insensitive analysis when it reaches the
call site at line $6$ of \main{}.
Algorithm~\ref{fig:interFlow} illustrates our context-insensitive
algorithm.
%For instance, the intraprocedural analysis of function
%\compute{} is able to detect that its return value
%(\texttt{sum}) might be tainted at line $13$. This
%result, stored in the summary table, is then used during
%the analysis of procedure \main{}, which calls
%\compute{} at line $6$.

%During the subsequent analysis of \main, the fact that variable
%\texttt{y} gets tainted at line $6$ is known directly from the
%summary table information written by \compute. This can then
%be used for further taint propagation.

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the intraprocedural analysis. The table
has even more precise information if the context-insensitive
analysis was performed.
Algorithm~\ref{fig:csInterFlow} presents the transfer equations
for the context-sensitive analysis.
 
Algorithm~\ref{fig:algoAnalyze} represents the pseudo code of
our analysis algorithm\footnote{Adapted from Jonathan Aldrich's
lecture notes} \texttt{Analyze}, and Table~\ref{symTable}
describes the symbols we use.

We define a set of C standard library functions that
we considered as sources. These library functions are not
further analyzed during \texttt{Analyze}'s run.
Instead we provide for them annotations that specify
which of their parameters becomes tainted after they
have run. Appendix !!! lists the C standard library
functions the analysis considers as sources.

On the other hand, we also predefine a set of functions
we consider as sinks. These functions are handled similarly
to the previous described sources. Appendix !!! lists
the C standard library functions the analysis considers
as sinks.

Function \texttt{InterFlow} (Algorithm~\ref{fig:algoFlow})
implements the analysis' transfer equations.

\paragraph{Recursive and Mutual Recursive Function Calls} 

\paragraph{Complex Data Structures}

Our analysis ignore recursive function calls: the dataflow set
before and after recursive calls are identical. 

We detect recursive mutual function calls by finding strongly
connected components of the call graph generated by LLVM.
Mutual recursive functions are replaced with one single ...


\subsection{Motivating Example Case Study}\label{sec:sampleSummary}


