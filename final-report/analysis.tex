\section{Staged Analysis}\label{stagedAnalysis}

\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\myinflow}{\mathit{inFlow}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}

\paragraph{Intraprocedural Analysis}

Our analysis is composed of an intraprocedural and an interprocedural
part. When the intraprocedural analysis detects a tainted value, it
writes this information to a summary table. This information is 
used in later stages by the interprocedural analysis, thus improving
the analysis runtime. 
For instance, the intraprocedural analysis detects that variable
\texttt{sum} of procedure \compute{} in Figure~\ref{fig:sample} is tainted.
Algorithm~\ref{fig:intraFlow} shows the analysis' intraprocedural
transfer function. 

Our analysis dataflow set is $\varset \times \instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to
statements where $v$ might be tainted. If $v$ might not
be tainted before statment $s$, then $\myinflow_s[v] = \emptyset$.
Otherwise, $\myinflow_s[v]$ contains statements where $v$
might get tainted.

\IncMargin{1em}
\begin{algorithm*}
\caption{IntraFlow: Intraprocedural Analysis Transfer Equations}\label{fig:intraFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Output[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\uCase{$\LSTORE\ [*p = q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;		
			\If{$\Input[\stmtQ] \neq \emptyset$}{			
				$\Output[\stmtT_k] \leftarrow \Output[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
	\Case{$\LSOURCE\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\ForEach{$k \in \set{0, 1, ..., n}$}{
			\If{$\Taint(k)$}{			
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k] \cup \set{\stmt}$\;
			}			
		}
	}	
	\uCase{$\LCALL\ [\stmtR = \mathit{call}\ \Func]$}{
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\ForEach{$\stmtF_k \in \Formals(\mathit{Proc})$}{
	\If{$\Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
		$\summaryTable[\Func][k] = 1$\;
	}
}
\end{algorithm*}
\DecMargin{1em}
Developers can choose between a context-insensitive
and a context-sensitive analysis. However, the intraprocedural
analysis is always run first. 

\paragraph{Context-Insensitive Analysis}
Our context-insensitive analysis is performed
in the reverse topological order of the call graph.
This phase performs an intraprocedural analysis of each
procedure and stores its result in a summary table.
The summary table tells us whether the return value or
a parameter of the procedure might be tainted at runtime.
The data from the summary table are then used by subsequent
analyses of procedures in the call graph. 

For instance, an intraprocedural analysis of function \compute
is able to detect that its return value (\texttt{sum})
might be tainted at line $13$. This result, stored in the
summary table, is then used during the analysis of procedure
\main, which calls \compute at line $6$.

During the subsequent analysis of \main, the fact that variable
\texttt{y} gets tainted at line $6$ is known directly from the
summary table information written by \compute. This can then
be used for further taint propagation.

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the context-insensitive analysis.
 
\subsection{Analysis algorithm} 
\begin{table}
\begin{tabular}{|l|l|}
\hline
\textbf{Symbols}				&	\textbf{Description}								\\ \hline
$\mathit{D}$					&	$\mathit{Var} \rightarrow 2^\mathit{Inst}$			\\
								&	Analysis dataflow set 								\\ \hline
$\mathit{Proc}$					&	Set of all program functions and procedures 		\\ \hline
$\mathit{Inst}$					&	Set of instructions in the program 					\\ \hline
$\mathit{inFlow}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point before an instruction 			\\ 	\hline
$\mathit{outFlow}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point after an instruction 			\\ 	\hline	    		
$\mathit{worklist}$				&	Set of remaining instructions to be processed 		\\ \hline
$\mathit{InterFlow}$					&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&   Analysis flow function (Algorithm~\ref{fig:algoFlow}) 			\\ \hline
$\mathit{first}$				&	$\mathit{Func} \rightarrow\ \mathit{Inst}$ 			\\
								& 	Function that returns the first instruction			\\
								&	of a procedure										\\ \hline
$\mathit{next}$					&	$\mathit{worklist}\ \rightarrow\ \mathit{Inst}$ 	\\
								& 	Function that returns the next instructions			\\
								&	from the worklist									\\ \hline
$\mathit{formal}$				&	$\mathit{Proc}\ \times \mathit{Var} \rightarrow\ \mathit{Var}$ 	\\
								& 	Function that returns the formal parameter $f_k$	\\
								&	of a procedure or function for its actual $a_k$		\\ \hline	
$\mathit{toplevel}$				&	$\mathcal{A}\ \rightarrow\ \mathcal{P}$ 			\\
								& 	Function that returns top-level variables for		\\
								&	an address taken variable							\\ \hline															
$\pointsto{\overline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to before program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline					
$\pointsto{\underline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to after program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline
\end{tabular}
\caption{Algorithm Symbols}\label{symTable}
\end{table}
Algorithm~\ref{fig:algoAnalyze} represents the pseudo code of
our analysis algorithm\footnote{Adapted from Jonathan Aldrich's
lecture notes} \texttt{Analyze}, and Table~\ref{symTable}
describes the symbols we use.

\IncMargin{1em}
\begin{algorithm}
\caption{Analyze}\label{fig:algoAnalyze}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{func}{f}
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Output}{output}
\SetKwFunction{InFlow}{inFlow}
\SetKwFunction{OutFlow}{outFlow}
\SetKwFunction{InterFlow}{InterFlow}
\SetKwFunction{First}{first}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwFunction{AnalyzeAlgo}{Analyze}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Func: \mathit{Proc}, \newline
		 \InitDataFlow: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst})$}
\OutData{}
$ s_0 \leftarrow \First(\func)$\;
$\Input[s_0] \leftarrow \InitDataFlow(s_0)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ \neq\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] \leftarrow \InterFlow(\AnalyzeAlgo, \varI)$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] \leftarrow \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist \leftarrow \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm}
\DecMargin{1em}
We define a set of C standard library functions that
we considered as sources. These library functions are not
further analyzed during \texttt{Analyze}'s run.
Instead we provide for them annotations that specify
which of their parameters becomes tainted after they
have run. Appendix !!! lists the C standard library
functions the analysis considers as sources.

On the other hand, we also predefine a set of functions
we consider as sinks. These functions are handled similarly
to the previous described sources. Appendix !!! lists
the C standard library functions the analysis considers
as sinks.

\IncMargin{1em}
\begin{algorithm*}
\caption{InterFlow: Context-Insentive Flow Function}\label{fig:interFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case(//Same as IntraProc){$\LCOPY\ [\stmtP = \stmtQ] $}{
	}
	\Case(//Same as IntraProc){$\LLOAD\ [p = *q] $}{
	}	
	\Case(//Same as IntraProc){$\LSTORE\ [*p = q] $}{
	}	
	\Case(//Same as IntraProc){$\LSOURCE\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
	}
%Context-insensitive	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\summaryTable[\Func]\ \mathit{exists}$}{
			\If{$\summaryTable[\Func][n+1] = 1$}{
					$\Output[\stmtR] \leftarrow \set{\stmt}$\;						
			}			
			\ForEach{$\stmtA_k, k \in \set{0, 1, ..., n}$}{
				\If{$\summaryTable[\Func][k] = 1$}{
					$\Output[\stmtA_k] \leftarrow \Output[\stmtA_k] \cup  \set{\stmt}$\;																
				}							
			}
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}

\IncMargin{1em}
\begin{algorithm*}
\caption{csInterFlow: Context-Sentive Flow Function}\label{fig:csInterFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwData{summaryTable}{summaryTable}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Output[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\Case{$\LSTORE\ [*p = q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;		
			\If{$\Input[\stmtQ] \neq \emptyset$}{			
				$\Output[\stmtT_k] \leftarrow \Output[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
	\Case{$\LSOURCE\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\ForEach{$k \in \set{0, 1, ..., n}$}{
			\If{$\Taint(k)$}{			
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k] \cup \set{\stmt}$\;
			}			
		}
	}
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0$}{
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Input[\stmtF_k] \leftarrow \Input[\stmtF_k] \cup  \Input[\stmtB]$\;						
						}
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0\ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
						$\Output[\stmtA_k] \leftarrow \Output[\stmtF_k] \cup \set{\stmt}$;			
						$\summaryTable[\Func][k] = 1$\;
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Output[\stmtB] \leftarrow \Output[\stmtB] \cup \Output[\stmtA_k]$\;						
						}
					}
				}					
			}
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}
Function \texttt{InterFlow} (Algorithm~\ref{fig:algoFlow})
implements the analysis' transfer equations.

\subsection{Recursive and Mutual Recursive Function Calls} 

Our analysis ignore recursive functions calls: the dataflow set
before and after recursive calls are identical. 

We detect recursive mutual function calls by finding strongly
connected components of the ahead-of-time call graph generated
by LLVM. 

\subsection{Context-Sensitivity} 

We achieve context-sensitivity by analyzing callees
with dataflow set information of their formal parameters
at calling sites.

For instance in Figure~\ref{fig:sample}, the call to \even{} at
line $4$ would take into the account the fact that \texttt{x}
is tainted.
On the other hand, \even{}'s call at line $25$ can not safely
make this assumption.

\subsection{Motivating Example Case Study}\label{sec:sampleSummary}

\subsection{Handling of complex data structures}
