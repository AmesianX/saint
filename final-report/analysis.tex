\section{Staged Taint Analysis}\label{sec:analysis}

\newcommand{\varset}{\mathit{Var}\xspace}
\newcommand{\instset}{\mathit{Inst}\xspace}
\newcommand{\procset}{\mathit{Proc}\xspace}
\newcommand{\formalsset}{\mathit{formals}\xspace}
\newcommand{\aliases}{\mathit{aliases}\xspace}
\newcommand{\intset}{\mathbb{N}^+}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\taintfunc}{\mathit{taint}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\myoutflow}{\mathit{OUT}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

The taint analysis is interprocedural and runs
either context-insensitively or context-sensitively.
Any of the interprocedural analysis is always preceded
by a unique intraprocedural analysis that computes initial
information that are reused by the interprocedural analyses.
The intraprocedural analysis detects taint sources and
initializes a summary table which contains taint information
about program procedure's formal parameters and return value.
The use of a summary table allows fast access to key
information about program procedures. This is especially
useful during the subsequent interprocedural phases.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample}, which also holds the return
value of \compute{}, may be tainted due to the call
to \texttt{scanf} at line $13$. This information is then
reused by the context-insensitive analysis to infer that
variable y may hold a tainted value.
%Appendix~\ref{app:algo} presents pseudo code for all
%our analysis algorithms.

\paragraph{Taint Sources and Sinks}
Functions that taint variables (\textit{taint sources}) are discovered
during the intraprocedural analysis described later in this section.
The analysis considers a subset of standard C funtions to be taint sources:
{\tt getc, scanf, gets, fopen}, etc.
Developers are also allow to specify additional taint sources
by declaring them in a configuration file.

Taint sinks (functions that use tainted variables) are gradually
discovered during the various phases of the analysis. Developers
can specify sink functions by declaring them in a configuration
file. The analysis uses by default a subset of C functions as
sinks ({\tt  }, etc).

\paragraph{Taint Propagation}
The analysis only performs \textit{explicit taint propagation}
(data-flow taint propagation). Explicit taint propagation tracks variables
that are tainted due to assignment statements. The assignment in line $6$
of Figure~\ref{fig:sample} is an instance of explicit taint propagation.
Variable $y$ becomes tainted since it gets assigned the return value of
\texttt{compute}, which is tainted value.\\
The analysis does not perform \textit{implicit taint propagation}
(control-flow propagation), which is another type of taint propagation.
Implicit taint propagation also takes into account tainted variables
used in control conditions. For instance, if a tainted variable $x$ is
used in the boolean condition of an if-statement, then variables
assigned in both branches of the statement becomes tainted because
their value depend on tainted variable $x$.

\paragraph{Formalisms}
The analysis dataflow set is $\instset \times 2^\varset$,
where $\instset$ the set of all program instructions
and $\varset$ is the set of all program variables. 
At a statement labelled $s$, the incoming dataflow set $\myinflow[s]$
is the set of program variables that are tainted before statement $s$.
If a variable $v$ is not tainted before statement $s$, then
$v \notin \myinflow[s]$; otherwise $\myinflow[s]$ contains $v$.

This paper uses the following elements to describe the
taint analysis:
$\varset$ is the set of all program variables,
$\procset$ is the set of all program functions and procedures\footnote{We
will use the terms function and procedure interchangeably in
the remainder of this paper.},
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before the statement labelled s, 
$\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after the statement labelled s,
$\taintfunc: \intset \rightarrow bool$ returns \texttt{true}
if function $f$ always taints its $k^{th}$ formal parameter, and
$\aliases: \varset \rightarrow 2^\varset$ returns the alias set of
a variable as returned by the pointer analysis.

\paragraph{Pointer Analysis}
This paper's taint analysis is designed to work using the results of
a previously computed pointer analysis.
The current implementation uses the pointer analysis \DSA (\texttt{Data Structure Analysis}) \cite{DSA:PLDI07}.
\DSA is a field- and context-sensitive pointer analysis.
\DSA uses full heap cloning (by acyclic call paths) and 
scales well with programs in a size range of 100K-200K lines of C code. 
Algorithm~\ref{fig:insertTaint} illustrates how the taint analysis uses
the results of the pointer analysis using function \texttt{aliases}
to update data flowsets.
\begin{algorithm}
\caption{flowInsert. Insertion of Taint Information}\label{fig:insertTaint}
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{Input}{IN}
\SetKwData{ValueV}{v}
\SetKwData{ValueW}{$a_v$}
\SetKwData{Output}{OUT}
\SetKwFunction{Aliases}{aliases}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\stmt: \mathit{Inst}, \ValueV: \mathit{Var}$}
\OutData{}
$\Output[\stmt] \leftarrow \Output[\stmt] \cup \{ \ValueV \}$\;
	\ForEach{$\ValueW \in \Aliases(\ValueV)$}{			
		$\Output[\stmt] \leftarrow \Output[\stmt] \cup \{ \ValueW \}$\;
	}
\end{algorithm}

\paragraph{Intraprocedural Analysis}
The intraprocedural analysis always runs first, before any of
the interprocedural analyses, and is responsible for discovering
initial taint sources. During the intraprocedural analysis,
program functions are analyzed in the reverse topological order
of the call graph (i.e starting from the leaves of the callgraph).
The analysis works on each function body and do not take into account
the interprocedural control flow. The computed data flow sets are
reused later by the subsequent interprocedural analyses. In particular,
taint information about function formal parameters and return
value is kept in a global summary table. All tainted variables due
to source functions are found during the intraprocedural analysis.
For instance, the intraprocedural analysis detects that variable
\texttt{sum} of function \compute{} in Figure~\ref{fig:sample}
may be tainted at line $13$ due to the call to \texttt{scanf}, which
the analysis considers as a taint source. 
Algorithm~\ref{fig:intraFlow} shows the flow function for
\callt statements, which handles the discovery of taint sources
during the intraprocedural analysis pass.
Flow functions for all other statement types are same as the ones
of Algorithm~\ref{fig:csInterFlow} in Appendix~\ref{app:algo}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\caption{Intraprocedural Analysis Flow Function for \callt statements}\label{fig:intraFlow}
%\SetAlgoNoLine
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{VarA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtR}{r}
\SetKwData{VarK}{k}
\SetKwData{summaryTable}{summary}
\SetKwData{Input}{IN}
\SetKwData{Output}{OUT}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Source}{source}
\SetKwFunction{Formals}{formals}
\SetKwFunction{FlowInsert}{flowInsert}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Source(\VarA_0, \VarA_1, ..., \VarA_n)]$}{
		\ForEach{$\VarK \in \set{0, 1, ..., n}$}{
			\If{$\summaryTable[\Source][\VarK]$}{			
				$\FlowInsert(\stmt, \VarA_k)$\;
			}			
		}
	}			
}
\ForEach{$\stmtF_k \in \Formals(\Caller)$}{
	\If{$\Output[\stmt] \neq \Input[\stmt]$ {\bf and} $\stmtF_k \in \Output[\stmt]$}{
		$\summaryTable[\Caller][\VarK] = 1$\;
	}
}
\end{algorithm}

\paragraph{Context-Insensitive Analysis}
The context-insensitive analysis starts from the \textit{main function}
(entry point of the program) and performs in the topological order
of the call graph. It uses function return value taint assumptions
from the intraprocedural analysis and applies them whenever available.
The context-insensitive analysis does not propagate taint information
from the caller to the callee that may happen through callee arguments.
It only uses function return taint information from the intraprocedural
analysis  and further propagates it.
For instance, the intraprocedural analysis of function \main{}
marks the return value of \compute (stored in variable \texttt{sum})
as tainted in the summary table. At line $6$ in \main, the context-insensitive
analysis  would take into account that the return value of \compute is
stored into variable \texttt{y}. Thus, \texttt{y} becomes a
tainted variable during the context-insensitive analysis.
Algorithm~\ref{fig:interFlow} in the following
illustrates the context-insensitive flow function for \callt statements.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\caption{Context-Insentive Interprocedural Flow Function for
\callt statements}\label{fig:interFlow}
%\SetAlgoNoLine
%\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{ValueV}{v}
\SetKwData{VarA}{a}
\SetKwData{stmtF}{f}
\SetKwData{VarK}{k}
\SetKwData{ValueR}{r}
\SetKwData{summaryTable}{summary}
\SetKwData{Input}{IN}
\SetKwData{Output}{OUT}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{Func}{G}
\SetKwFunction{FlowInsert}{flowInsert}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{		
	\Case{$\LCALL\ [\ValueR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\summaryTable[\Func][n+1]$}{
			$\FlowInsert(\stmt, \ValueR)$\;						
		}			
		\ForEach{$\VarK \in \set{0, 1, ..., n}$}{
			\If{$\summaryTable[\Func][\VarK]$}{
				$\FlowInsert(\stmt, \VarA_k)$\;						
			}							
		}
	}				
}
\end{algorithm}

\paragraph{Context-Sensitive Analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\caption{csInterFlow: Context-Sentive Flow Function for \callt
statements}\label{fig:contextIF}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtR}{r}
\SetKwData{False}{false}
\SetKwData{Input}{IN}
\SetKwData{Output}{OUT}
\SetKwData{summaryTable}{summary}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Func}{G}
\SetKwFunction{Formals}{formals}
\SetKwFunction{FlowInsert}{flowInsert}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(\stmtA_0, \stmtA_1, ..., \stmtA_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k]$}{	
							$\FlowInsert(\stmt, \stmtA_k)$;											
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$!\summaryTable[\Func][k] \ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{		
						$\summaryTable[\Func][k] = 1$\;						
						$\FlowInsert(\stmt, \stmtA_k)$\;				
					}
				}					
			}
		}
	}				
}
\end{algorithm}

The context-sensitive analysis works in the topological order
of the call graph, and uses information from the summary table
that were produced by previous analyses. Even if the context-insensitive
analysis was run before, the context-sensitive analysis eventually
finds more precise information in the summary table. At call sites,
the context-sensitive analysis propagates actual parameters
taint information from the caller into the callee. At callees' exits,
newly computed taint information are propagated back from the
callee to the caller context. Algorithm~\ref{fig:contextIF}
illustrates the flow function for \callt statements during the
context-sensitive analysis. On the other hand, algorithm~\ref{fig:csInterFlow}
in Appendix~\ref{app:algo} presents the full context-sensitive
algorithm.

\paragraph{Recursive and Mutual Recursive Function Calls} 
The context-sensitive analysis computes results for simple recursive
functions only for their first calling context.

Our current implementation does not handle mutual recursive function
calls in a specific manner. However, we plan to handle
this in future work as explained below.

The analysis identifies mutual recursive function calls by finding
strongly connected components (SCC) in the call graph generated
by LLVM.

There is no particular treatment of mutual recursive function
calls during the context-insensitive analysis. Only the
procedure information from the summary table is used.

During the context-sensitive analysis, functions in the call
graph that builds a SCC are analyzed together.
That is, when a call to one function of a SCC happens,
the analysis starts from that function and propagates taint
information at call sites of all other functions in the SCC
set, but each function is analyzed once.

\paragraph{Complex Data Structures}

Given the limited scope of this project, we are not handling
complex data structures such as array and structures.
However, we plan to report the usage of tainted C structures
(\texttt{struct}) and arrays in future work.