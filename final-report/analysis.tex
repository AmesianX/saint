\section{Analysis}\label{stagedAnalysis}

\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\myinflow}{\mathit{inFlow}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}

Our taint analysis is interprocedural and can be run
either context-insensitively or context-sensitively.
Our analysis builds and uses a summary table that contains
taint information about program procedure formal parameters
and return value.
The initial values of the summary table are written by
an intraprocedural analysis that runs prior to any variant
of the interprocedural analysis. The use of the
summary table enables us to reuse information that has
already been computed by any previous analysis. For
instance, the intraprocedural analysis would detect that
variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample} may be tainted due to the call
to \texttt{scanf} at line $13$. This information is then
reused by the subsequent interprocedural analyses.

Our analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program statements where $v$ might be tainted.
If $v$ might not be tainted before statment $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

\paragraph{Pointer Analysis}
Our analysis is designed to work by using the results of
a prior computed pointer analysis. This may enable us to
do various experimentations with different types of pointer
analyses. For this project, we choose to use \lothak{}'s
hybrid pointer analysis \cite{Lhotak:2011:PAE}. \cite{Lhotak:2011:PAE}
is a pointer analysis that attempts to benefit from the
advantages of both flow-insensitive and flow-sensitive 
pointer analyses. It is implemented as an extension of
Andersen's interprocedural flow-insensitive analysis that
also produces flow-sensitive information. The analysis'
algorithm relies on the observation that strong updates
are only possible whenever an abstract pointer location is
a singleton set. Therefore the analysis works as a
flow-insensitive analysis, but applies flow-sensitive
rules whenever an abstract pointer location is a singleton set.
The evaluation results of the paper show that the performance
of the strong update analysis is comparable to that of a
flow-insensitive analysis. The results also show that the hybrid
analysis provides the same benefits as a fully flow-sensitive
analysis at $98\%$ of stores and loads in the program.

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse topological
order of the call graph.
The intraprocedural analysis works on each function body and
do not take into account interprocedural control flow.
Once it detects that a tainted value is written to a variable,
it writes this information to the summary table. The
information from the summary table is used in later stages
by the interprocedural analyses.
For instance, all tainted variables due to source functions
are found by the intraprocedural analysis.
For instance, the intraprocedural analysis detects that variable
\texttt{sum} of procedure \compute{} of our running example
(Figure~\ref{fig:sample}) may be tainted due to the call
to \texttt{scanf} at line $13$. Algorithm~\ref{fig:intraFlow}
shows the analysis' intraprocedural transfer functions. 
\IncMargin{1em}
\begin{algorithm*}
\caption{IntraFlow: Intraprocedural Analysis Transfer Equations}\label{fig:intraFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Output[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\uCase{$\LSTORE\ [*p = q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;		
			\If{$\Input[\stmtQ] \neq \emptyset$}{			
				$\Output[\stmtT_k] \leftarrow \Output[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
	\Case{$\LSOURCE\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\ForEach{$k \in \set{0, 1, ..., n}$}{
			\If{$\Taint(k)$}{			
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k] \cup \set{\stmt}$\;
			}			
		}
	}	
	\uCase{$\LCALL\ [\stmtR = \mathit{call}\ \Func]$}{
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\ForEach{$\stmtF_k \in \Formals(\mathit{Proc})$}{
	\If{$\Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
		$\summaryTable[\Func][k] = 1$\;
	}
}
\end{algorithm*}
\DecMargin{1em}
Developers can choose between a context-insensitive
and a context-sensitive analysis. However, the intraprocedural
analysis is always run first. 

\paragraph{Context-Insensitive Analysis}
Our context-insensitive analysis is performed
in the reverse topological order of the call graph,
and uses results from the intraprocedural analysis
stored in the summary table whenever available.
Taint assumptions about callee actual paramneters
at call sites are done based on the values present
in the summary table. The analysis itself does not
attempt to propagate flow set values from the caller
to the callee.
For instance, the intraprocedural analysis of function
\main{} marks variable \texttt{x} as tainted in the
summary table. This is information is then used by
the context-insensitive analysis when it reaches the
call site at line $6$ of \main{}.
Algorithm~\ref{fig:interFlow} illustrates our context-insensitive
algorithm.
%For instance, the intraprocedural analysis of function
%\compute{} is able to detect that its return value
%(\texttt{sum}) might be tainted at line $13$. This
%result, stored in the summary table, is then used during
%the analysis of procedure \main{}, which calls
%\compute{} at line $6$.

%During the subsequent analysis of \main, the fact that variable
%\texttt{y} gets tainted at line $6$ is known directly from the
%summary table information written by \compute. This can then
%be used for further taint propagation.

\IncMargin{1em}
\begin{algorithm*}
\caption{InterFlow: Context-Insentive Flow Function}\label{fig:interFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case(//Same as IntraProc){$\LCOPY\ [\stmtP = \stmtQ] $}{
	}
	\Case(//Same as IntraProc){$\LLOAD\ [p = *q] $}{
	}	
	\Case(//Same as IntraProc){$\LSTORE\ [*p = q] $}{
	}	
%Context-insensitive	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\summaryTable[\Func]\ \mathit{exists}$}{
			\If{$\summaryTable[\Func][n+1] = 1$}{
					$\Output[\stmtR] \leftarrow \set{\stmt}$\;						
			}			
			\ForEach{$\stmtA_k, k \in \set{0, 1, ..., n}$}{
				\If{$\summaryTable[\Func][k] = 1$}{
					$\Output[\stmtA_k] \leftarrow \Output[\stmtA_k] \cup  \set{\stmt}$\;																
				}							
			}
		}
	}		
	\uCase{$\LSOURCE\ [\stmtR = \mathit{call}\ \Func]$}{
	}	
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the intraprocedural analysis. The table
has even more precise information if the context-insensitive
analysis was performed.
Algorithm~\ref{fig:csInterFlow} presents the transfer equations
for the context-sensitive analysis.
 
\subsection{Analysis algorithm} 
\begin{table}
\begin{tabular}{|l|l|}
\hline
\textbf{Symbols}				&	\textbf{Description}								\\ \hline
$\mathit{D}$					&	$\mathit{Var} \rightarrow 2^\mathit{Inst}$			\\
								&	Analysis dataflow set 								\\ \hline
$\mathit{Proc}$					&	Set of all program functions and procedures 		\\ \hline
$\mathit{Inst}$					&	Set of instructions in the program 					\\ \hline
$\mathit{inFlow}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point before an instruction 			\\ 	\hline
$\mathit{outFlow}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point after an instruction 			\\ 	\hline	    		
$\mathit{worklist}$				&	Set of remaining instructions to be processed 		\\ \hline
$\mathit{InterFlow}$					&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&   Analysis flow function (Algorithm~\ref{fig:algoFlow}) 			\\ \hline
$\mathit{first}$				&	$\mathit{Func} \rightarrow\ \mathit{Inst}$ 			\\
								& 	Function that returns the first instruction			\\
								&	of a procedure										\\ \hline
$\mathit{next}$					&	$\mathit{worklist}\ \rightarrow\ \mathit{Inst}$ 	\\
								& 	Function that returns the next instructions			\\
								&	from the worklist									\\ \hline
$\mathit{formal}$				&	$\mathit{Proc}\ \times \mathit{Var} \rightarrow\ \mathit{Var}$ 	\\
								& 	Function that returns the formal parameter $f_k$	\\
								&	of a procedure or function for its actual $a_k$		\\ \hline	
$\mathit{toplevel}$				&	$\mathcal{A}\ \rightarrow\ \mathcal{P}$ 			\\
								& 	Function that returns top-level variables for		\\
								&	an address taken variable							\\ \hline															
$\pointsto{\overline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to before program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline					
$\pointsto{\underline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to after program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline
\end{tabular}
\caption{Algorithm Symbols}\label{symTable}
\end{table}
Algorithm~\ref{fig:algoAnalyze} represents the pseudo code of
our analysis algorithm\footnote{Adapted from Jonathan Aldrich's
lecture notes} \texttt{Analyze}, and Table~\ref{symTable}
describes the symbols we use.

\IncMargin{1em}
\begin{algorithm}
\caption{Analyze}\label{fig:algoAnalyze}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{func}{f}
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Output}{output}
\SetKwFunction{InFlow}{inFlow}
\SetKwFunction{OutFlow}{outFlow}
\SetKwFunction{InterFlow}{InterFlow}
\SetKwFunction{First}{first}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwFunction{AnalyzeAlgo}{Analyze}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Func: \mathit{Proc}, \newline
		 \InitDataFlow: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst})$}
\OutData{}
$ s_0 \leftarrow \First(\func)$\;
$\Input[s_0] \leftarrow \InitDataFlow(s_0)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ \neq\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] \leftarrow \InterFlow(\AnalyzeAlgo, \varI)$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] \leftarrow \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist \leftarrow \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm}
\DecMargin{1em}
We define a set of C standard library functions that
we considered as sources. These library functions are not
further analyzed during \texttt{Analyze}'s run.
Instead we provide for them annotations that specify
which of their parameters becomes tainted after they
have run. Appendix !!! lists the C standard library
functions the analysis considers as sources.

On the other hand, we also predefine a set of functions
we consider as sinks. These functions are handled similarly
to the previous described sources. Appendix !!! lists
the C standard library functions the analysis considers
as sinks.

\IncMargin{1em}
\begin{algorithm*}
\caption{csInterFlow: Context-Sentive Flow Function}\label{fig:csInterFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{inFlow$_s$}
\SetKwData{Output}{outFlow$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwData{summaryTable}{summaryTable}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Output[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\Case{$\LSTORE\ [*p = q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;		
			\If{$\Input[\stmtQ] \neq \emptyset$}{			
				$\Output[\stmtT_k] \leftarrow \Output[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0$}{
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Input[\stmtF_k] \leftarrow \Input[\stmtF_k] \cup  \Input[\stmtB]$\;						
						}
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0\ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
						$\Output[\stmtA_k] \leftarrow \Output[\stmtF_k] \cup \set{\stmt}$;			
						$\summaryTable[\Func][k] = 1$\;
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Output[\stmtB] \leftarrow \Output[\stmtB] \cup \Output[\stmtA_k]$\;						
						}
					}
				}					
			}
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}
Function \texttt{InterFlow} (Algorithm~\ref{fig:algoFlow})
implements the analysis' transfer equations.

\begin{figure}
\[
	\mathit{GEN}(s)	=
	\begin{cases}
		\set{s},	&\text{COPY\ [$p = q$]}	\\
		\bigcup_{}^{} \myinflow{}[t_k]\ \text{where} t_k = [\mathit{toplevel(a_k)}],	&\text{LOAD\ [$p = *q$]}	\\		
		\set{s},	&\text{STORE\ [$*p = q$]}				
	\end{cases}
\]
\caption{Kill and Gen Sets}
\end{figure}

\subsection{Recursive and Mutual Recursive Function Calls} 

Our analysis ignore recursive functions calls: the dataflow set
before and after recursive calls are identical. 

We detect recursive mutual function calls by finding strongly
connected components of the ahead-of-time call graph generated
by LLVM. 

\subsection{Context-Sensitivity} 

We achieve context-sensitivity by analyzing callees
with dataflow set information of their formal parameters
at calling sites.

For instance in Figure~\ref{fig:sample}, the call to \even{} at
line $4$ would take into the account the fact that \texttt{x}
is tainted.
On the other hand, \even{}'s call at line $25$ can not safely
make this assumption.

\subsection{Motivating Example Case Study}\label{sec:sampleSummary}

\subsection{Handling of complex data structures}
