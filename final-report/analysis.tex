\section{Staged Taint Analysis}\label{sec:analysis}

\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\procset}{\mathit{Proc}}
\newcommand{\formalsset}{\mathit{formals}}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\myoutflow}{\mathit{OUT}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

Our taint analysis is interprocedural and runs
either context-insensitively or context-sensitively.
Any of the interprocedural analysis is always preceded
by a unique intraprocedural analysis that computes initial
information that are reused by the interprocedural analyses.
The intraprocedural analysis detects taint sources and
initializes a summary table which contains taint information
about program procedure's formal parameters and return value.
The use of a summary table allows fast access to key
information about program procedures. This is especially
useful during the subsequent interprocedural phases.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample}, which also holds the return
value of \compute{}, may be tainted due to the call
to \texttt{scanf} at line $13$. This information is then
reused by the context-insensitive analysis to infer that
variable y may hold a tainted value.
Appendix~\ref{app:algo} presents pseudo code for all
our analysis algorithms.

\paragraph{Taint Sources and Sinks}

\paragraph{Taint Propagation}

\paragraph{Formalisms}
Our analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program tainting statements.
If $v$ is definitely not tainted before statement $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

We use the following elements to describe our analysis:
$\varset$ is the set of all program variables,
$\procset$ is the set of all program functions and procedures\footnote{We
will use the terms function and procedure interchangeably in
the remainder of this paper.},
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before the statement labelled s,
and $\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after the statement labelled s.
\begin{comment}
\begin{figure*}
\[
\begin{array}{lcl}
	\myoutflow[p] & = & \emptyset,\   \addrofdef	\\
		
	\myoutflow[r] & = & \emptyset,\   \sinkdef	\\
			
	\myoutflow[p] & = & \set{s},\   \copydef	\\
				
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{q}}{} \myinflow{}_s[t_k]\, t_k =\ \mathit{toplevel(a_k)},\   \loaddef	\\		
			
	\myoutflow[p] & = & \mybigcup{a_k \in\ \pointsto{s}{p}}{} \myinflow{}_s[t_k] \cup \myinflow{}_s[q]\, t_k =\ \mathit{toplevel(a_k)},\
	   \storedef	\\
	   
	\myoutflow[p] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ \text{taint}(f_k) \equiv\ 
	\text{true},\   \sourcedef	\\
	
	\myoutflow[r] & = & \myinflow{}_s[r] \cup \set{s},\ \text{summaryTable}[\text{func}][n+1] \equiv\ 1,\	\callinsdef	\\							

	\myoutflow[a_k] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \set{s},\ 
		\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\callinsdef	\\							
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[r] & = & \mybigcup{f_k \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\
	
	\myoutflow[b] & = & \mybigcup{b \in\ \text{formals}(s)}{} \myinflow{}_s[f_k] \cup \myinflow{}_s[r] \cup \set{s}\,
	\text{summaryTable}[\text{func}][k] \equiv\ 1,\	\calldef	\\			
\end{array}
\]
\caption{Transfer Equations}
\end{figure*}
\end{comment}
\paragraph{Pointer Analysis}
Our analysis is designed to work using the results of
a previously computed pointer analysis. This may enable
us to experiment with different pointer analyses.
For this project, we chose the pointer analysis
\DSA (\texttt{Data Structure Analysis}) \cite{DSA:PLDI07}.
\DSA is a field- and context-sensitive pointer analysis.
\DSA uses full heap cloning (by acyclic call paths) and 
still scales well with programs in a size range of 100K-200K
lines of C code. 
\DSA operates in three phases: \textit{local}, \textit{bottom-up},
and \textit{top-down}.

\paragraph{Taint Propagation}

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse
topological order of the call graph (i.e starting
from the leaves of the callgraph).
The intraprocedural analysis works on each function
body and do not take into account interprocedural
control flow. The computed data flow sets are reused
later on by the subsequent interprocedural analyses.
In particular, taint information about function
formal parameters and return value is kept in a
global summary table.
All tainted variables due to source functions are
found by the intraprocedural analysis. 
For instance, the intraprocedural analysis detects
that variable \texttt{sum} of function \compute{}
in Figure~\ref{fig:sample} may be tainted due to the
call to \texttt{scanf} at line $13$.
The intraprocedural analysis always runs
first, before the interprocedural context-insensitive
or context-sensitive analyses.
The pseudo code for the intraprocedural analysis
is showed in Algorithm~\ref{fig:intraFlow}.

\paragraph{Context-Insensitive Analysis}
The context-insensitive analysis starts from the
\textit{main function} (entry point of the program) and
performs in the topological order of the call graph.
It uses function return value taint assumptions from the
intraprocedural analysis and applies them whenever available.
The context-insensitive analysis does not attempt
to propagate flow set values from the caller to the callee.
It only updates flow set values of function returns
(computed during the intraprocedural run) and further
propagates taint information.
For instance, the intraprocedural analysis of function
\main{} marks the return value of \compute
(stored in variable \texttt{sum}) as tainted in the summary
table. At line $6$ of \main, the context-insensitive analysis 
would take into account that the return value of \compute
is stored into variable \texttt{y}. Thus, \texttt{y}
becomes a tainted variable.
Algorithm~\ref{fig:interFlow} in Appendix~\ref{app:algo}
illustrates the context-insensitive algorithm.

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and used information from the summary table
that were produced by the intraprocedural analysis. If the
context-insensitive analysis was run before, the context-sensitive
analysis eventually finds more precise information in the summary
table.
At call sites, the context-sensitive analysis propagates
actual parameters' taint information from the caller to the
callee. At callees' exit, newly computed taint information
are propagated back from the callee to the caller context.
Algorithm~\ref{fig:csInterFlow} in Appendix~\ref{app:algo}
presents our context-sensitive algorithm in detail.

\paragraph{Recursive and Mutual Recursive Function Calls} 
Our analysis ignores recursive function calls: the dataflow set
before and after recursive calls is identical.
We detect recursive mutual function calls by finding strongly
connected components (SCC) in the call graph generated by LLVM.

There is no particular treatment of mutual recursive function
calls during the context-insensitive analysis. Only the
procedure information from the summary table is used.

On the other hand, functions on the call graph that builds a
SCC are analyzed together during the context-sensitive analysis.
That is, when a call to one function of a SCC happens,
the analysis starts from that function and propagates taint
information at call sites of all other functions in the SCC set,
but each function is analyzed once.

\paragraph{Complex Data Structures}

We are not handling complex data structures in this project.
However, we plan to report the usage of tainted C structures
(\texttt{struct}) and arrays in future work.