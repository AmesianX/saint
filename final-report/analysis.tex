\section{Staged Taint Analysis}\label{sec:analysis}

\newcommand{\varset}{\mathit{Var}}
\newcommand{\instset}{\mathit{Inst}}
\newcommand{\procset}{\mathit{Proc}}
\newcommand{\formalsset}{\mathit{formals}}
\newcommand{\firstfunc}{\mathit{first}}
\newcommand{\toplevelfunc}{\mathit{toplevel}}
\newcommand{\taintfunc}{\mathit{taint}}
\newcommand{\pointsto}[2]{{pt}_{[#1]}(#2)}
\newcommand{\pointstobefore}[2]{{pt}_{[\overline{#1}]	}(#2)}
\newcommand{\pointstoafter}[2]{{pt}_{[\underline{#1}]}(#2)}

\newcommand{\myinflow}{\mathit{IN}}
\newcommand{\myoutflow}{\mathit{OUT}}
\newcommand{\ifff}{\mathit{iff}}
\newcommand{\aand}{\mathit{and}}
\newcommand{\mybigcup}[2]{\mathlarger{\bigcup_{#1}^{#2}}}

The taint analysis is interprocedural and runs
either context-insensitively or context-sensitively.
Any of the interprocedural analysis is always preceded
by a unique intraprocedural analysis that computes initial
information that are reused by the interprocedural analyses.
The intraprocedural analysis detects taint sources and
initializes a summary table which contains taint information
about program procedure's formal parameters and return value.
The use of a summary table allows fast access to key
information about program procedures. This is especially
useful during the subsequent interprocedural phases.
For instance, the intraprocedural analysis would
detect that variable \texttt{sum} of procedure \compute{} in
Figure~\ref{fig:sample}, which also holds the return
value of \compute{}, may be tainted due to the call
to \texttt{scanf} at line $13$. This information is then
reused by the context-insensitive analysis to infer that
variable y may hold a tainted value.
%Appendix~\ref{app:algo} presents pseudo code for all
%our analysis algorithms.

\paragraph{Taint Sources and Sinks}
Functions that taint variables (\textit{taint sources}) are discovered
during the intraprocedural analysis described later in this section.
The analysis considers a subset of standard C funtions to be taint sources:
{\tt getc, scanf, gets, fopen}, etc.
Developers are also allow to specify additional taint sources
by declaring them in a configuration file.

Taint sinks (functions that use tainted variables) are gradually
discovered during the various phases of the analysis. Developers
can specify sink functions by declaring them in a configuration
file. The analysis uses by default a subset of C functions as
sinks ({\tt  }, etc).

\paragraph{Taint Propagation}
The analysis only performs \textit{explicit taint propagation}
(data-flow taint propagation). Explicit taint propagation tracks variables
that are tainted due to assignment statements. The assignment in line $6$
of Figure~\ref{fig:sample} is an instance of explicit taint propagation.
Variable $y$ becomes tainted since it gets assigned the return value of
\texttt{compute}, which is tainted value.\\
The analysis does not perform \textit{implicit taint propagation}
(control-flow propagation), which is another type of taint propagation.
Implicit taint propagation also takes into account tainted variables
used in control conditions. For instance, if a tainted variable $x$ is
used in the boolean condition of an if-statement, then variables
assigned in both branches of the statement becomes tainted because
their value depend on tainted variable $x$.

\paragraph{Formalisms}
The analysis dataflow set is $\varset \times 2^\instset$,
where $\varset$ is the set of all program variables and
$\instset$ the set of all program statements. 
At a statement labelled $s$, the incoming dataflow set $\myinflow_s$
is a mapping from each program variable $v$ to a set of
previous program tainting statements.
If $v$ is definitely not tainted before statement $s$, then
$\myinflow_s[v] = \emptyset$. Otherwise, $\myinflow_s[v]$
contains statements where $v$ might get tainted.

This paper uses the following elements to describe the
taint analysis:
$\varset$ is the set of all program variables,
$\procset$ is the set of all program functions and procedures\footnote{We
will use the terms function and procedure interchangeably in
the remainder of this paper.},
$\instset$ is the set of all program statements,
$\firstfunc{}: \procset \rightarrow \instset$ returns the first
statement of a function,
$\formalsset{}: \procset \rightarrow 2^{\varset}$ returns the
set of formal parameters of a function, 
$\toplevelfunc{}: \Aset \rightarrow \Pset$ returns the top level
variable of an address-taken variable,
$\pointstobefore{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable before the statement labelled s, 
$\pointstoafter{s}{}: \varset \rightarrow 2^\Aset$ returns the
points-to set of a variable after the statement labelled s,
and $\taintfunc: \varset \rightarrow bool$ returns \texttt{true}
if the formal parameter at position $k$ of procedure $f$ is always
tainted during execution of $f$.

\paragraph{Pointer Analysis}
This paper's taint analysis is designed to work using the results of
a previously computed pointer analysis.
The current implementation uses the pointer analysis
\DSA (\texttt{Data Structure Analysis}) \cite{DSA:PLDI07}.
\DSA is a field- and context-sensitive pointer analysis.
\DSA uses full heap cloning (by acyclic call paths) and 
scales well with programs in a size range of 100K-200K lines of C code. 
%\DSA operates in three phases: \textit{local}, \textit{bottom-up},
%and \textit{top-down}.

\paragraph{Intraprocedural Analysis}
Program functions are analyzed in the reverse topological order
of the call graph (i.e starting from the leaves of the callgraph).
The intraprocedural analysis works on each function body and do
not take into account interprocedural control flow. The computed
data flow sets are reused later by the subsequent interprocedural
analyses. In particular, taint information about function
formal parameters and return value is kept in a global summary table.
All tainted variables due to source functions are found during
the intraprocedural analysis. For instance, the intraprocedural
analysis detects that variable \texttt{sum} of function \compute{}
in Figure~\ref{fig:sample} may be tainted due to the call to
\texttt{scanf} at line $13$. The intraprocedural analysis always
runs first, before any of the interprocedural analyses. 
Algorithm~\ref{fig:intraFlow} in the following shows the flow
function for the \callt statement during the intraprocedural analysis.
Flow functions for all other statement types are same as the ones
of Algorithm~\ref{fig:csInterFlow} in Appendix~\ref{app:algo}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm}
\caption{Intraprocedural Analysis Flow Function for the \callt statement}\label{fig:intraFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN$_s$}
\SetKwData{Output}{OUT$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\ForEach{$k \in \set{0, 1, ..., n}$}{
			\If{$\Taint(k)$}{			
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k]$\;
			}			
		}
	}			
}
\ForEach{$\stmtF_k \in \Formals(\mathit{Proc})$}{
	\If{$\Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
		$\summaryTable[\Func][k] = 1$\;
	}
}
\end{algorithm}
\DecMargin{1em}

\paragraph{Context-Insensitive Analysis}
The context-insensitive analysis starts from the \textit{main function}
(entry point of the program) and performs in the topological order
of the call graph. It uses function return value taint assumptions
from the intraprocedural analysis and applies them whenever available.
The context-insensitive analysis does not propagate taint information
from the caller to the callee that may happen through callee arguments.
It only uses function return taint information from the intraprocedural
analysis  and further propagates it.
For instance, the intraprocedural analysis of function \main{}
marks the return value of \compute (stored in variable \texttt{sum})
as tainted in the summary table. At line $6$ in \main, the context-insensitive
analysis  would take into account that the return value of \compute is
stored into variable \texttt{y}. Thus, \texttt{y} becomes a
tainted variable during the context-insensitive analysis.
Algorithm~\ref{fig:interFlow} in the following
illustrates the context-insensitive algorithm.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm}[!htbp]
\caption{InterFlow: Context-Insentive Flow Function for \callt
statement. Flow functions for other statement types are same
as the one for the intraprocedural analysis}\label{fig:interFlow}
%\SetAlgoNoLine
%\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN$_s$}
\SetKwData{Output}{OUT$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}

\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{	
%Context-insensitive	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\summaryTable[\Func][n+1] = 1$}{
			$\Output[\stmtR] \leftarrow \Input[\stmtR]$\;						
		}			
		\ForEach{$\stmtA_k, k \in \set{0, 1, ..., n}$}{
			\If{$\summaryTable[\Func][k] = 1$}{
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k]$\;																
			}							
		}
	}				
}
\end{algorithm}
\DecMargin{1em}

\paragraph{Context-Sensitive Analysis}
The context-sensitive analysis works in the topological order
of the call graph, and uses information from the summary table
that were produced by previous analyses. Even if the context-insensitive
analysis was run before, the context-sensitive analysis eventually
finds more precise information in the summary table. At call sites,
the context-sensitive analysis propagates actual parameters
taint information from the caller into the callee. At callees' exits,
newly computed taint information are propagated back from the
callee to the caller context. Algorithm~\ref{fig:csInterFlow}
in Appendix~\ref{app:algo} presents our context-sensitive
algorithm in detail.

\paragraph{Recursive and Mutual Recursive Function Calls} 
The context-sensitive analysis computes results for simple recursive
functions only for their first calling context.
The analysis identifies mutual recursive function calls by finding
strongly connected components (SCC) in the call graph generated
by LLVM.

There is no particular treatment of mutual recursive function
calls during the context-insensitive analysis. Only the
procedure information from the summary table is used.

During the context-sensitive analysis, functions in the call
graph that builds a SCC are analyzed together.
That is, when a call to one function of a SCC happens,
the analysis starts from that function and propagates taint
information at call sites of all other functions in the SCC
set, but each function is analyzed once.

\paragraph{Complex Data Structures}

Given the limited scope of this project, we are not handling
complex data structures such as array and structures.
However, we plan to report the usage of tainted C structures
(\texttt{struct}) and arrays in future work.