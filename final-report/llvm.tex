\section{LLVM's Intermediate Representation}\label{sec:llvm}

This section gives an overview of LLVM's intermediate
representation (IR), which we use as basis for the
description of our analysis.

LLVM's IR uses partial static single assignment (SSA)
and assumes the existence of only two types of variables
in C code: \textit{top-level} and \textit{address-taken}
variables.

Top-level variables are in SSA form and can not be
accessed indirectly via a pointer. That is, their memory
address is never copied to another variable (i.e. they are
never applied the address-of operator). Top-level variables
are accessed with \alloct and \copyt instructions.
This paper denotes the set of top-level variables
with $\Pset$. For instance, $b1$, and $b2$ in Figure~\ref{fig:sample}
are top-level variables ($\{b1, b2\} \in \Pset$).

Address-taken variables are never accessed directly through
their first declared name. Address-taken variables are only
accessed indirectly through pointer variables with \loadt and
\storet instructions. In fact, address-taken variables
are those ones on which the address-of operator (\texttt{\&})
was applied. This paper uses $\Aset$ for the set of all address-taken
variables. Variable \texttt{x} in Figure~\ref{fig:sample} is
for instance an address-taken variable ($x \in \Aset$).

This paper describes the analysis by using the following abstract
instructions:
\begin{itemize}
\item $\copydef$: copy instruction. $p, q \in \Aset$.
\item $\loaddef$: load instruction. $q \in \Aset$.
\item $\storedef$: store instruction. $p \in \Aset, q \in \Pset$.
\item $\calldef$: call to a function. $r \in \Pset$
\item $\sinkdef$: call to a sink function. $r \in \Pset$
\end{itemize}
