\section{Analysis Algorithms}\label{app:algo}

In this section, algorithm~\ref{fig:csInterFlow} shows the full
pseudo-algorithm for the context-sensitive analysis described
in Section~\ref{sec:analysis}.
Only the handling of the \callt statement is specific to
the context-sensitive algorithm. All other flow functions
are common to the intraprocedural and context-insensitive
analysis, both described in Section~\ref{sec:analysis} as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm*}[!h]
\caption{csInterFlow: Context-Sentive Analysis Algorithm}\label{fig:csInterFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN}
\SetKwData{Output}{OUT}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwData{summaryTable}{sumTable}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwFunction{FlowInsert}{flowInsert}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\stmtQ \in \Input[\stmt]$}{
			$\FlowInsert(\stmt, \stmtP)$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;					
			\If{$\stmtT_k \in \Input[\stmt]$}{
				$\FlowInsert(\stmt, \stmtP)$\;
				$break$
			}
		}
	}	
	\Case{$\LSTORE\ [*p = q] $}{
		\If{$\stmtQ \in \Input[\stmt]$}{	
			%\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
				%$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;					
				%$\Output[\stmtT_k] \leftarrow \Input[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
				$\FlowInsert(\stmt, \stmtP)$;
			%}
		}	
	}	
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0$}{
						%\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							%$\Input[\stmtF_k] \leftarrow \Input[\stmtF_k] \cup  \Input[\stmtB]$\;		
							$\FlowInsert(\stmt, \stmtA_k)$;											
						%}
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0\ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
						%$\Output[\stmtA_k] \leftarrow \Output[\stmtF_k] \cup \set{\stmt}$;			
						$\summaryTable[\Func][k] = 1$\;						
						$\FlowInsert(\stmt, \stmtA_k)$\;				
					}
				}					
			}
		}
	}		
%	\uCase{$\LADDROF\ [p = \&a]$}{
%	}	
%	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
%	}		
}
\end{algorithm*}
\DecMargin{1em}
