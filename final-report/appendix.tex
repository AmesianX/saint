\section{Analysis Algorithms}\label{app:algo}

This section presents a listing of all analysis algorithms
we describe in this paper in Section~\ref{sec:analysis}.

Algorithm~\ref{fig:algoAnalyze} presents the standard worklist
based interprocedural algorithm for fixed point computation.
The intraprocedural algorithm is illustrated in
Algorithm~\ref{fig:intraFlow}. Algorithm~\ref{fig:interFlow}
and algorithm~\ref{fig:algoAnalyze}ef{fig:csInterFlow} show the context-insensitive
and context-sensitive analysis respectively.

\IncMargin{1em}
\begin{algorithm}[!htbp]
\caption{Analyze}\label{fig:algoAnalyze}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Output}{output}
\SetKwFunction{InterFlow}{InterFlow}
\SetKwFunction{First}{first}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwFunction{AnalyzeAlgo}{Analyze}
\SetKwFunction{Func}{main}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Func: \mathit{Proc}, \newline
		 \Input: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst}), \newline
		 \Output: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst})$}
\OutData{}
$ s_0 \leftarrow \First(\Func)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ \neq\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] \leftarrow \InterFlow(\AnalyzeAlgo, \varI)$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] \leftarrow \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist \leftarrow \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm}
\DecMargin{1em}

%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm*}[!h]
\caption{csInterFlow: Context-Sentive Flow Function.}\label{fig:csInterFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN$_s$}
\SetKwData{Output}{OUT$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwData{summaryTable}{summaryTable}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\Case{$\LSTORE\ [*p = q] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{	
			\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
				$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;					
				$\Output[\stmtT_k] \leftarrow \Input[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0$}{
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Input[\stmtF_k] \leftarrow \Input[\stmtF_k] \cup  \Input[\stmtB]$\;						
						}
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0\ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
						$\Output[\stmtA_k] \leftarrow \Output[\stmtF_k] \cup \set{\stmt}$;			
						$\summaryTable[\Func][k] = 1$\;
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Output[\stmtB] \leftarrow \Output[\stmtB] \cup \Output[\stmtA_k]$\;						
						}
					}
				}					
			}
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}
