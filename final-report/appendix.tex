\section{Analysis Algorithms}\label{app:algo}

\begin{comment}
\begin{table}[!h]
\begin{tabular}{|l|l|}
\hline
\textbf{Symbols}				&	\textbf{Description}								\\ \hline
$\mathit{D}$					&	$\mathit{Var} \rightarrow 2^\mathit{Inst}$			\\
								&	Analysis dataflow set 								\\ \hline
$\mathit{Proc}$					&	Set of all program functions and procedures 		\\ \hline
$\mathit{Inst}$					&	Set of instructions in the program 					\\ \hline
$\mathit{IN}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point before an instruction 			\\ 	\hline
$\mathit{OUT}$				&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&	Function that returns the dataflow values			\\
		    					&	at the program point after an instruction 			\\ 	\hline	    		
$\mathit{worklist}$				&	Set of remaining instructions to be processed 		\\ \hline
$\mathit{InterFlow}$					&	$\mathit{Inst}\ \rightarrow\ \mathit{D}$ 			\\
								&   Analysis flow function (Algorithm~\ref{fig:algoFlow}) 			\\ \hline
$\mathit{first}$				&	$\mathit{Func} \rightarrow\ \mathit{Inst}$ 			\\
								& 	Function that returns the first instruction			\\
								&	of a procedure										\\ \hline
$\mathit{next}$					&	$\mathit{worklist}\ \rightarrow\ \mathit{Inst}$ 	\\
								& 	Function that returns the next instructions			\\
								&	from the worklist									\\ \hline
$\mathit{formal}$				&	$\mathit{Proc}\ \times \mathit{Var} \rightarrow\ \mathit{Var}$ 	\\
								& 	Function that returns the formal parameter $f_k$	\\
								&	of a procedure or function for its actual $a_k$		\\ \hline	
$\mathit{toplevel}$				&	$\mathcal{A}\ \rightarrow\ \mathcal{P}$ 			\\
								& 	Function that returns top-level variables for		\\
								&	an address taken variable							\\ \hline															
$\pointsto{\overline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to before program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline					
$\pointsto{\underline{s}}{q}$	&	Set of program locations to which variable q		\\
								&	may point to after program statement $s$			\\
								& 	(i.e $q$'s \textit{points-to set} at statement $s$)	\\ \hline
\end{tabular}
\caption{Algorithm Symbols}\label{symTable}
\end{table}
\end{comment}

\IncMargin{1em}
\begin{algorithm*}[!h]
\caption{Analyze}\label{fig:algoAnalyze}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{func}{f}
\SetKwData{varJ}{j}
\SetKwData{varI}{i}
\SetKwData{worklist}{worklist}
\SetKwFunction{Input}{input}
\SetKwFunction{Output}{output}
\SetKwFunction{InterFlow}{InterFlow}
\SetKwFunction{First}{first}
\SetKwFunction{Update}{Update}
\SetKwFunction{InitDataFlow}{initDataFlow}
\SetKwFunction{Next}{next}
\SetKwFunction{Succs}{succs}
\SetKwFunction{AnalyzeAlgo}{Analyze}
\SetKwFunction{Func}{func}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Func: \mathit{Proc}, \newline
		 \InitDataFlow: \mathit{Inst} \rightarrow (\mathit{Var} \rightarrow 2^\mathit{Inst})$}
\OutData{}
$ s_0 \leftarrow \First(\func)$\;
$\Input[s_0] \leftarrow \InitDataFlow(s_0)$\;
$\worklist \leftarrow \set{s_0}$\;
\While{ $\worklist\ \neq\ \emptyset$ }{
	$\varI \leftarrow \Next(\worklist)$\;
	$\Output[i] \leftarrow \InterFlow(\AnalyzeAlgo, \varI)$\;
	\ForEach{ $\varJ \in \Succs(\varI)$ }{
		\If{ $\Output[\varI] \not\sqsubseteq \Input[\varJ]$}{
			$\Input[\varJ] \leftarrow \Input[\varJ] \sqcup \Output[\varI]$\;
			$\worklist \leftarrow \worklist \cup\ \set{\varJ}$\;
		}	
	}
}
\end{algorithm*}
\DecMargin{1em}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm*}[!h]
\caption{InterFlow: Context-Insentive Flow Function}\label{fig:interFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{summaryTable}{summaryTable}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN$_s$}
\SetKwData{Output}{OUT$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case(//Same as IntraProc){$\LCOPY\ [\stmtP = \stmtQ] $}{
	}
	\Case(//Same as IntraProc){$\LLOAD\ [p = *q] $}{
	}	
	\Case(//Same as IntraProc){$\LSTORE\ [*p = q] $}{
	}	
%Context-insensitive	
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\summaryTable[\Func][n+1] = 1$}{
			$\Output[\stmtR] \leftarrow \Input[\stmtR] \cup \set{\stmt}$\;						
		}			
		\ForEach{$\stmtA_k, k \in \set{0, 1, ..., n}$}{
			\If{$\summaryTable[\Func][k] = 1$}{
				$\Output[\stmtA_k] \leftarrow \Input[\stmtA_k] \cup  \set{\stmt}$\;																
			}							
		}
	}		
	\uCase{$\LSOURCE\ [\stmtR = \mathit{call}\ \Func]$}{
	}	
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\IncMargin{1em}
\begin{algorithm*}[!h]
\caption{csInterFlow: Context-Sentive Flow Function}\label{fig:csInterFlow}
%\SetAlgoNoLine
\SetAlgoLined
\LinesNumbered
\DontPrintSemicolon
\SetKwData{Caller}{caller}
\SetKwData{stmt}{s}
\SetKwData{stmtV}{v}
\SetKwData{stmtA}{a}
\SetKwData{stmtF}{f}
\SetKwData{stmtK}{k}
\SetKwData{stmtR}{r}
\SetKwData{stmtT}{t}
\SetKwData{stmtB}{b}
\SetKwData{stmtQ}{q}
\SetKwData{stmtP}{p}
\SetKwData{tainted}{tainted}
\SetKwData{fZero}{$f_0$}
\SetKwData{False}{False}
\SetKwData{Input}{IN$_s$}
\SetKwData{Output}{OUT$_s$}
\SetKwData{TmpFlow}{tmpFlow}
\SetKwData{summaryTable}{summaryTable}
\SetKwFunction{Map}{map}
\SetKwFunction{LCOPY}{COPY}
\SetKwFunction{LLOAD}{LOAD}
\SetKwFunction{LSTORE}{STORE}
\SetKwFunction{LADDROF}{ADDROF}
\SetKwFunction{LCALL}{CALL}
\SetKwFunction{LSOURCE}{SOURCE}
\SetKwFunction{LSINK}{SINK}
\SetKwFunction{Type}{TypeOf}
\SetKwFunction{TaintUse}{taintUse}
\SetKwFunction{Update}{Update}
\SetKwFunction{InterFlow}{csInterFlow}
\SetKwFunction{Taint}{taint}
\SetKwFunction{Func}{func}
\SetKwFunction{First}{first}
\SetKwFunction{Formal}{formal}
\SetKwFunction{Formals}{formals}
\SetKwFunction{Toplevel}{toplevel}
\SetKwInOut{InData}{input}
\SetKwInOut{OutData}{output}


\InData{$\Caller: \mathit{Proc}, \stmt: \mathit{Inst}$}
\OutData{}
\Switch{$\Type(\stmt)$}{
	\Case{$\LCOPY\ [\stmtP = \stmtQ] $}{
		\If{$\Input[\stmtQ] \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtQ] \cup \set{\stmt}$;
		}
	}
	\Case{$\LLOAD\ [p = *q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{q}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$;		
			$\TmpFlow \leftarrow \TmpFlow \cup \Input[\stmtT_k]$\;				
		}
		\If{$\TmpFlow \neq \emptyset$}{
			$\Output[\stmtP] \leftarrow \Input[\stmtP] \cup \TmpFlow \cup \set{\stmt}$\;
		}
	}	
	\Case{$\LSTORE\ [*p = q] $}{
		\ForEach{$\stmtA_k \in \pointsto{\overline{\stmt}}{p}$}{
			$\stmtT_k \leftarrow \Toplevel(\stmtA_k)$\;		
			\If{$\Input[\stmtQ] \neq \emptyset$}{			
				$\Output[\stmtT_k] \leftarrow \Input[\stmtT_k] \cup \Input[\stmtQ] \cup \set{\stmt}$\;				
			}
		}	
	}	
%Context-sensitive		
	\Case{$\LCALL\ [\stmtR = \mathit{call}\ \Func(a_0, a_1, ..., a_n)]$}{
		\If{$\Caller \neq \Func$}{
			\If{$0 \in \summaryTable[\Func]$}{
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0$}{
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Input[\stmtF_k] \leftarrow \Input[\stmtF_k] \cup  \Input[\stmtB]$\;						
						}
					}
				}											
				$\InterFlow(\Caller, \Func)$\;			
				\ForEach{$\stmtF_k \in \Formals(\Func)$}{
					\If{$\summaryTable[\Func][k] = 0\ \aand\ \Output[\stmtF_k] \neq \Input[\stmtF_k]$}{
						$\Output[\stmtA_k] \leftarrow \Output[\stmtF_k] \cup \set{\stmt}$;			
						$\summaryTable[\Func][k] = 1$\;
						\ForEach{$\stmtB \in \pointsto{\overline{\stmt}}{\stmtA_k}$}{
							$\Output[\stmtB] \leftarrow \Output[\stmtB] \cup \Output[\stmtA_k]$\;						
						}
					}
				}					
			}
		}
	}		
	\uCase{$\LADDROF\ [p = \&a]$}{
	}	
	\Case{$\LSINK [\stmtR = \mathit{call}\ \Func]$}{
	}		
}
\end{algorithm*}
\DecMargin{1em}