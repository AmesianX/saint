\section{Introduction}
Software vulnerabilities are security threats
that exist in an application when users may exercise
unauthorized  control of the application through supplied input.
Such unauthorized control are classified in different
categories : \textit{buffer overflow}, \textit{SQL
injection}, \textit{cross site scripting}, etc.

Both dynamic and static techniques exist to alleviate
security vulnerabilities in software. 
This project aims at using \textit{\textbf{static taint analysis}}
to prevent software vulnerabilities.
Taint analysis searches program external inputs
usage that may allow users to gain unauthorized control
over the program. 

We now introduce key terms used in taint analysis.
A \textit{source} is a program location that may produce
an \textit{tainted value}, i.e, a value from an untrusted
program input (e.g. return value from a system call, user input). 
A \textit{sanitizer} is a function that validates tainted
values and make them safe (trusted, untainted) for further
program usage.
\textit{Sinks} are program locations that may use tainted
values (e.g. a function call may have a tainted value as
actual argument).

Taint analysis proceeds by first tagging values from sources
as tainted . Once tagged, Input data taint information is
propagated through the program.
\textit{Taint propagation} is the process of marking as tainted
values resulting from operations involving tainted data. In the
last step, taint analysis emits a warning whenever a tainted
value is used at a sink location.

Taint propagation can be \textit{dataflow} or \textit{control-flow} based.
Dataflow based propagation are explicit and exist due to data
dependencies in the program. Statement $s_u$ is data dependent
on statement $s_d$ if there exists a \textit{def-use} relationship
between $s_d$ and $s_u$. Figure~\ref{fig:dfpropagation} illustrates
an example of dataflow taint propagation. 
%The statement at line $3$
%is data dependent on the statement at line $3$ because variable
%\texttt{\$credit} is defined at line $2$ and used at line $3$.

\begin{figure}[!h]
\begin{center}
\EmbedCode{c}{dfpropagation.c}{left}
\end{center}
\caption{Example code for dataflow taint propagation}
\label{fig:dfpropagation}
\end{figure}

Control-flow based propagation are implicit and are due to
control dependencies. A statement $s_t$ is control dependent on
a statement $s_s$ if $s_s$ contains a predicate $p$ and the execution
of $s_t$ may depend on $p$'s evaluation.
%Figure~\ref{fig:cfpropagation} illustrates an example of
%control-flow taint propagation: after invocation of the sanitizer function
%\myvar{ctype\_digit}, if the control flows in the else-branch, then uses of
%variable \myvar{amount} will not be tainted. On the other hand,
%\myvar{amount} remains tainted in the if-branch.

\begin{figure}[!h]
\begin{center}
\EmbedCode{c}{cfpropagation.c}{left}
\end{center}
\caption{Example code for control-flow taint propagation}
\label{fig:cfpropagation}
\end{figure}

Given a tainted input \texttt{tStr}, table~\ref{analysis:propagation:t1}
describes how program operations propagate taint information. The table
will be extended as the project advances.
We assume that statements involving arithmetic operators (e.g., $+, -$, etc.)
are transformed in a three-address code. The same applies for string
concatenations that use $+$.