\section{Analysis}\label{analysis}

We will implement our analysis as a fixed-point iteration
over the set of program statements. For each program function $f$,
the analysis will generate a summary and use it whenever
a call to $f$ is encountered.
Section~\ref{sec:summaries} handles function summary generation.

Figure~\ref{fig:rules} shows the analysis' transfer functions.
For a pointer variable $q$, we define \(p[s](q)\) as the set
of program locations to which q may point to (i.e $q$ \textit{points-to set})
at the program statement labelled with $s$.
$In_s$ and $Out_s$ represent the dataflow set \textit{before}
and \textit{after} statement $s$ respectively. 
For a tainted variable $t$, $S_t$ is the set of previous
statements which use $t$ as tainted variable.

\begin{comment}
\begin{table}[h!]
\begin{center}
\begin{tabular}{c|l}
Symbols & Description 	\\ \hline
\(In_s \)			& Dataflow set before statement $s$		\\	\hline
\(Out_s \)			& Dataflow set after statement $s$		\\  \hline
\(S_v \)			& Set of statements that use tainted variable $v$		\\
\end{tabular}
\caption{Symbol Description}
\end{center}
\end{table}
\end{comment}

Our analysis essentially works in two steps. The
first step consists in creating a summary for each
function.

\begin{figure}[!h]
\[
\infer[\COPY]
  {In_s \cup \set{(q, S_q)} \cup \set{(p, \set{s})}}
  {In_s \cup \set{(q, S_q)} & s:p = q}
\qquad
\infer[\LOAD]
  {In_s \cup \set{(pt[s](q), S_{pt[s](q)})} \cup \set{(p, \set{s})}}
  {In_s \cup \set{(pt[s](q), S_{pt[s](q)})}   & s:p = *q}
\]
\[
\infer[\ADDROF]
  {In_s }
  {In_s & s:p = \&a}
\qquad  
\infer[\STORE]
  {In_s \cup \set{(q, S_q)} \cup \set{(p[s](p), \set{s})} }
  {In_s \cup \set{(q, S_q)} & s:*p = q}
\qquad
\infer[\CALL]
  {\set{}}
  {\set{} & s:call\ f}  
\]
\caption{Transfer Functions}
\label{fig:rules}
\end{figure}

\subsection{Motivating Example Case Study}\label{sec:sampleSummary}

\subsection{Summary Generation}\label{sec:summaries}

Function summaries will be generated in the reverse
topological order of the callgraph. Each strongly connected
component (SCC) of the callgraph will be handled as one
node. That is, a single summary will be generated for
mutual recursive functions. In our motivating example
from Figure~\ref{fig:sample}, only one summary will
be generated for functions \even{} and \odd{} because they
are mutually recursive.
Figure~\ref{fig:summary} shows the algorithm for function
summary generation.

Given a function $f$, our analysis will generate and use
a summary for $f$. Let $\set{i_0, i_1, ..., i_j}$ be the set
of $f$'s formal parameters. Let assume that all global variables
are accessible in $f$ through a set of local variables 
$G = \set{g_0, g_1, ..., g_k}$. $f$'s summary is a set of integers 
$\mathcal{S}(f) = \set{0, 1, ...,m, n, ..., z}$.
We now describe f's summary 
defined as follows: 

Figure~\ref{} illustrates the function summary for \main{}
of Figure~\ref{fig:sample}

\subsection{Handling of complex data structures}

\subsection{Context-Sensitivity} 

We achieve context-sensitivity by analyzing callees
with dataflow set information of their formal parameters
at calling sites.

For instance in Figure~\ref{fig:sample}, the call to \even{} at
line $4$ would take into the account the fact that \texttt{x}
is tainted.
On the other hand, \even{}'s call at line $25$ can not safely
make this assumption.