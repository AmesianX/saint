[STTAL]module identifier is <stdin>
[STTAL]discovered function odd
[STTAL]discovered function even
[STTAL]discovered function main
[STTAL]discovered function compute
## Starting intraprocedural analysis
[Processing][Function][compute]
STORE [*p=q]:   store i32* %x, i32** %1, align 8
LOAD [p=*q]:   %2 = load i32** %1, align 8
LOAD [p=*q]:   %3 = load i32* %2
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %sum)
  %sum = alloca i32, align 4 gets tainted
Found a source __isoc99_scanf with arg_pos 1
STORE [*p=q]:   store i32 0, i32* %sum, align 4
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %sum)
Found a source __isoc99_scanf with arg_pos 1
STORE [*p=q]:   store i32 0, i32* %i, align 4
STORE [*p=q]:   store i32 0, i32* %sum, align 4
STORE [*p=q]:   store i32 0, i32* %i, align 4
STORE [*p=q]:   store i32 0, i32* %i, align 4
LOAD [p=*q]:   %11 = load i32* %i, align 4
LOAD [p=*q]:   %12 = load i32* %sum, align 4
  %12 = load i32* %sum, align 4 gets tainted
LOAD [p=*q]:   %11 = load i32* %i, align 4
LOAD [p=*q]:   %12 = load i32* %sum, align 4
LOAD [p=*q]:   %15 = load i32* %sum, align 4
  %15 = load i32* %sum, align 4 gets tainted
LOAD [p=*q]:   %16 = load i32** %1, align 8
LOAD [p=*q]:   %17 = load i32* %16
STORE [*p=q]:   store i32 %18, i32* %16
LOAD [p=*q]:   %23 = load i32* %sum, align 4
  %23 = load i32* %sum, align 4 gets tainted
Analyzing return instruction for compute
	  %23 = load i32* %sum, align 4
	is tainted
LOAD [p=*q]:   %15 = load i32* %sum, align 4
LOAD [p=*q]:   %16 = load i32** %1, align 8
LOAD [p=*q]:   %17 = load i32* %16
STORE [*p=q]:   store i32 %18, i32* %16
LOAD [p=*q]:   %20 = load i32* %i, align 4
STORE [*p=q]:   store i32 %21, i32* %i, align 4
LOAD [p=*q]:   %20 = load i32* %i, align 4
STORE [*p=q]:   store i32 %21, i32* %i, align 4
LOAD [p=*q]:   %11 = load i32* %i, align 4
LOAD [p=*q]:   %12 = load i32* %sum, align 4
LOAD [p=*q]:   %23 = load i32* %sum, align 4
Analyzing return instruction for compute
	  %23 = load i32* %sum, align 4
	is tainted
[Processing][Function][main]
STORE [*p=q]:   store i32 0, i32* %1
CALL [call func]:   %2 = call noalias i8* @malloc(i64 25) #1
STORE [*p=q]:   store i8* %2, i8** %d, align 8
CALL [call func]:   %4 = call double @atof(i8* %3) #2
LOAD [p=*q]:   %5 = load i8** %d, align 8
CALL [call func]:   call void @free(i8* %5) #1
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %x)
  %x = alloca i32, align 4 gets tainted
Found a source __isoc99_scanf with arg_pos 1
LOAD [p=*q]:   %8 = load i32* %x, align 4
  %8 = load i32* %x, align 4 gets tainted
CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %b1, align 4
CALL [call func]:   %10 = call i32 @odd(i32 3)
STORE [*p=q]:   store i32 %10, i32* %b2, align 4
CALL [call func]:   %11 = call i32 @compute(i32* %x)
STORE [*p=q]:   store i32 %11, i32* %y, align 4
LOAD [p=*q]:   %13 = load i32* %y, align 4
CALL [call func]:   %14 = call i32 (i8*, i8*, ...)* @sprintf(i8* %12, i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32 %13) #1
Analyzing return instruction for main
	i32 0
[Processing][Function][even]
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 1, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @odd(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
STORE [*p=q]:   store i32 1, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for even
	  %11 = load i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @odd(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for even
	  %11 = load i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for even
	  %11 = load i32* %1
[Processing][Function][odd]
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 0, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
STORE [*p=q]:   store i32 0, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for odd
	  %11 = load i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for odd
	  %11 = load i32* %1
LOAD [p=*q]:   %11 = load i32* %1
Analyzing return instruction for odd
	  %11 = load i32* %1
Analyzing formal parameter x of function compute
Analyzing formal parameter x of function even
Analyzing formal parameter x of function odd
## Starting interprocedural analysis
[Processing][Function][main]
STORE [*p=q]:   store i32 0, i32* %1
CALL [call func]:   %2 = call noalias i8* @malloc(i64 25) #1
CONTEXT CALL [call func]:   %2 = call noalias i8* @malloc(i64 25) #1
	We do not analyze function 'malloc'
STORE [*p=q]:   store i8* %2, i8** %d, align 8
CALL [call func]:   %4 = call double @atof(i8* %3) #2
CONTEXT CALL [call func]:   %4 = call double @atof(i8* %3) #2
	We do not analyze function 'atof'
LOAD [p=*q]:   %5 = load i8** %d, align 8
CALL [call func]:   call void @free(i8* %5) #1
CONTEXT CALL [call func]:   call void @free(i8* %5) #1
	We do not analyze function 'free'
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
CONTEXT CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
	We do not analyze function 'printf'
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %x)
CONTEXT CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %x)
	We do not analyze function '__isoc99_scanf'
LOAD [p=*q]:   %8 = load i32* %x, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
CONTEXT CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
  %2 = alloca i32, align 4 gets tainted
LOAD [p=*q]:   %3 = load i32* %2, align 4
  %3 = load i32* %2, align 4 gets tainted
STORE [*p=q]:   store i32 1, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
  %7 = load i32* %2, align 4 gets tainted
CALL [call func]:   %9 = call i32 @odd(i32 %8)
CONTEXT CALL [call func]:   %9 = call i32 @odd(i32 %8)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 0, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
CONTEXT CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 1, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @odd(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %9, i32* %b1, align 4
CALL [call func]:   %10 = call i32 @odd(i32 3)
CONTEXT CALL [call func]:   %10 = call i32 @odd(i32 3)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 0, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
CONTEXT CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 1, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @odd(i32 %8)
CONTEXT CALL [call func]:   %9 = call i32 @odd(i32 %8)
STORE [*p=q]:   store i32 %x, i32* %2, align 4
LOAD [p=*q]:   %3 = load i32* %2, align 4
STORE [*p=q]:   store i32 0, i32* %1
LOAD [p=*q]:   %7 = load i32* %2, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %9, i32* %1
LOAD [p=*q]:   %11 = load i32* %1
STORE [*p=q]:   store i32 %10, i32* %b2, align 4
CALL [call func]:   %11 = call i32 @compute(i32* %x)
CONTEXT CALL [call func]:   %11 = call i32 @compute(i32* %x)
STORE [*p=q]:   store i32* %x, i32** %1, align 8
  %1 = alloca i32*, align 8 gets tainted
LOAD [p=*q]:   %2 = load i32** %1, align 8
  %2 = load i32** %1, align 8 gets tainted
i32* %x 	 also gets tainted
  %16 = load i32** %1, align 8 	 also gets tainted
LOAD [p=*q]:   %3 = load i32* %2
  %3 = load i32* %2 gets tainted
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
CONTEXT CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
	We do not analyze function 'printf'
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %sum)
CONTEXT CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %sum)
	We do not analyze function '__isoc99_scanf'
STORE [*p=q]:   store i32 0, i32* %sum, align 4
STORE [*p=q]:   store i32 0, i32* %i, align 4
LOAD [p=*q]:   %11 = load i32* %i, align 4
LOAD [p=*q]:   %12 = load i32* %sum, align 4
LOAD [p=*q]:   %15 = load i32* %sum, align 4
LOAD [p=*q]:   %16 = load i32** %1, align 8
LOAD [p=*q]:   %17 = load i32* %16
  %17 = load i32* %16 gets tainted
STORE [*p=q]:   store i32 %18, i32* %16
LOAD [p=*q]:   %20 = load i32* %i, align 4
STORE [*p=q]:   store i32 %21, i32* %i, align 4
LOAD [p=*q]:   %23 = load i32* %sum, align 4
STORE [*p=q]:   store i32 %11, i32* %y, align 4
LOAD [p=*q]:   %13 = load i32* %y, align 4
CALL [call func]:   %14 = call i32 (i8*, i8*, ...)* @sprintf(i8* %12, i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32 %13) #1
CONTEXT CALL [call func]:   %14 = call i32 (i8*, i8*, ...)* @sprintf(i8* %12, i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32 %13) #1
	We do not analyze function 'sprintf'
## Starting context-insensitive interprocedural analysis
STORE [*p=q]:   store i32 0, i32* %1
CALL [call func]:   %2 = call noalias i8* @malloc(i64 25) #1
STORE [*p=q]:   store i8* %2, i8** %d, align 8
CALL [call func]:   %4 = call double @atof(i8* %3) #2
LOAD [p=*q]:   %5 = load i8** %d, align 8
CALL [call func]:   call void @free(i8* %5) #1
CALL [call func]:   %6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0))
Found sink function printf
	arg (0): i8* getelementptr inbounds ([23 x i8]* @.str, i32 0, i32 0)
CALL [call func]:   %7 = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32* %x)
LOAD [p=*q]:   %8 = load i32* %x, align 4
CALL [call func]:   %9 = call i32 @even(i32 %8)
STORE [*p=q]:   store i32 %9, i32* %b1, align 4
CALL [call func]:   %10 = call i32 @odd(i32 3)
STORE [*p=q]:   store i32 %10, i32* %b2, align 4
CALL [call func]:   %11 = call i32 @compute(i32* %x)
  %11 = call i32 @compute(i32* %x) gets tainted
STORE [*p=q]:   store i32 %11, i32* %y, align 4
  %y = alloca i32, align 4 gets tainted
LOAD [p=*q]:   %13 = load i32* %y, align 4
  %13 = load i32* %y, align 4 gets tainted
CALL [call func]:   %14 = call i32 (i8*, i8*, ...)* @sprintf(i8* %12, i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0), i32 %13) #1
Found sink function sprintf
	arg (0):   %12 = getelementptr inbounds [10 x i8]* %str, i32 0, i32 0
	arg (1): i8* getelementptr inbounds ([3 x i8]* @.str1, i32 0, i32 0)
	arg (2):   %13 = load i32* %y, align 4
## [WARNING][format string vulnerability]: 
	Tainted value  %13 = load i32* %y, align 4 is used in sink function 'sprintf'
Analyzing return instruction for main
	i32 0
